IRODS
=====
Steven K. Baum
v0.5, 2013-02-18
:doctype: book
:toc:
:icons:

:numbered:

[preface]

Executive Summary
-----------------

iRODS is a distributed filesystem that creates a virtual filesystem consisting
of some combination of directories on the machine on which it is running,
directories on other local and remote machines, and datasets residing on other
servers such as THREDDS and ERDDAP.  This virtual filesystem makes access to
the datasets residing in all those places transparent to the user.  When using
an iRODS client program, the user will see a list of available files and -
depending on the capabilities of the browser - be able to peruse file
metadata, download a file, and/or select and download spatial and temporal
subsets of a file.

A perspective on distributed filesystems can be obtained by a paper that
compares six of them including iRODS:

http://hal.archives-ouvertes.fr/docs/00/78/90/86/PDF/a_survey_of_dfs.pdf[+http://hal.archives-ouvertes.fr/docs/00/78/90/86/PDF/a_survey_of_dfs.pdf+]

wherein a distributed filesystem (DFS) is defined to "provide permanent
storage for sharing multiple files, and build a hierarchical and unified
view of these files by federating storage resources dispersed in a network."
A DFS should be:

* *transparent*: users should be able to access the system from wherever they
choose to log in, be able to perform the same operations on the DFS as they
can on their local filesystem (list files, obtain file sizes, etc.), and
should not have to worry about faults due to the distributed nature of the
filesystem thanks to fault tolerance mechanisms.

* *fault tolerant*: a fault tolerant system should not have to be stopped
because of transient or partial failures, with the list of possible faults
including network and server failures that make data and services
unavailable, and data integrity and consistency when several users
concurrently access data.

* *scalable*: the system should be able to efficiently leverage large numbers
of servers that are dynamically and continuously added to the system.


Overview
--------

Documentation about the iRODS (Integrated Rule-Oriented Data
System) package, a highly-configurable, open source technology used in
multiple high-demand production sites globally for data management, sharing
and integration.  iRODS is data grid middleware, a data management
infrastructure, and a framework for implementing data policy.
The system is a generic software infrastructure that can be tuned to
implement any desired data management application, including:

* a data grid for sharing data across collaborations;
* a digital library for publishing data;
* a preservation environment for long-term data retention;
* a data processing pipeline; and
* a system for federating real-time sensor data streams.

The key features of iRODS are that it:

* manages and automates data operations across distributed, heterogeneous
systems;
* functions independently of storage resources, i.e. it abstracts data
control away from the storage devices and device location; and
* the middleware layer allows data stewards to develop data services to
meet user needs without involving system administrators.

iRODS has a centralized architecture with two major components:

* the *iCat server* that stores metadata in a database and handles
queries to the metadata; and
* several *iRODS servers* that store data to storage resources.

An iCat server and several iRODS servers form a *zone*.
A zone can interoperate with other independent iRODS zones as
a federation of zones wherein each zone continues to operate
as a separate iRODS instance with separate administration.
Users in the various zones will be able - if given
permission - to access data and metadata from other zones, with
the authentication provided at the user's original zone
propagating automatically to the other zones.

The major features of the iRODS architecture are:

* a *data grid architecture* based on a client/server model that controls
interactions with distributed storage and compute resources;
* a *metadata catalog* managed in a database system (e.g. MySQL, PostgreSQL)
for maintaining the attributes of data and state informatino generated by
remote operations; and
* a *rule system* for enforcing and executing adaptive rules.

The iRODS system expresses management policies as computer actionable
rules, and management procedures as sets of remotely executable
services called microservices.  The rules control the execution of the
microservices, and the state information generated is stored in a
metadata catalog.


Resources
~~~~~~~~~

https://irods.org/[+https://irods.org/+]

iRODS 4.0.0 Manual (PDF) -
http://irods.org/dev/wp-content/uploads/2014/03/irods-manual-4.0.0.pdf[+http://irods.org/dev/wp-content/uploads/2014/03/irods-manual-4.0.0.pdf+]

iRODS Overview (PDF) -
http://irods.org/dev/wp-content/uploads/2012/04/SC12-iRODS-overview.pdf[+http://irods.org/dev/wp-content/uploads/2012/04/SC12-iRODS-overview.pdf+]

iRODS Overview: Intro. to Data Grids, Policy-Driven Data Management, and
Enterprise iRODS -
http://eirods.org/dev/wp-content/uploads/2012/08/irods-intro.pdf[+http://eirods.org/dev/wp-content/uploads/2012/08/irods-intro.pdf+]

iRODS Tutorial: I. Getting Started (PDF) -
http://eirods.org/dev/wp-content/uploads/2012/08/irods-getting-started.pdf[+http://eirods.org/dev/wp-content/uploads/2012/08/irods-getting-started.pdf+]

iRODS Tutorial: II. Data Grid Administration (PDF) -
http://eirods.org/dev/wp-content/uploads/2012/08/irods-admin.pdf[+http://eirods.org/dev/wp-content/uploads/2012/08/irods-admin.pdf+]

Microservice Developers Tutorial (PDF) -
http://irods.org/dev/wp-content/uploads/2012/04/microservice_tutorial.pdf[+http://irods.org/dev/wp-content/uploads/2012/04/microservice_tutorial.pdf+]

Resource Plugin Tutorial (PDF) -
http://irods.org/dev/wp-content/uploads/2012/04/Resource_Plugin_Tutorial_20131114.pdf[+http://irods.org/dev/wp-content/uploads/2012/04/Resource_Plugin_Tutorial_20131114.pdf+]

Composable Resources (PDF) -
http://irods.org/dev/wp-content/uploads/2013/02/eirods-composable-resources.pdf[+http://irods.org/dev/wp-content/uploads/2013/02/eirods-composable-resources.pdf+]

iRODS Admin Interface (PDF) -
http://eirods.org/dev/wp-content/uploads/2013/03/scotty-irods-admin-interface.pdf[+http://eirods.org/dev/wp-content/uploads/2013/03/scotty-irods-admin-interface.pdf+]

iRODS Wiki -
https://wiki.irods.org/index.php/IRODS:Data_Grids,_Digital_Libraries,_Persistent_Archives,_and_Real-time_Data_Systems[+https://wiki.irods.org/index.php/IRODS:Data_Grids,_Digital_Libraries,_Persistent_Archives,_and_Real-time_Data_Systems+]

EUDAT iRODS Deployment -
http://www.eudat.eu/User%20Documentation%20-%20iRODS%20Deployment.html[+http://www.eudat.eu/User%20Documentation%20-%20iRODS%20Deployment.html+]

iRODS Usage at GBIO -
http://gbio-pbil.ibcp.fr/en/cblanchet/irods/[+http://gbio-pbil.ibcp.fr/en/cblanchet/irods/+]

Analysis of Six Distributed File Systems (PDF) -
http://hal.archives-ouvertes.fr/docs/00/78/90/86/PDF/a_survey_of_dfs.pdf[+http://hal.archives-ouvertes.fr/docs/00/78/90/86/PDF/a_survey_of_dfs.pdf+]

Videos
^^^^^^

iRODS on YouTube -
http://www.youtube.com/results?search_query=irods[+http://www.youtube.com/results?search_query=irods+]

DICE Research on YouTube -
http://www.youtube.com/channel/UCNep6KfyRu7IgxEXZvAmv1g[+http://www.youtube.com/channel/UCNep6KfyRu7IgxEXZvAmv1g+]

iRODS: The Integrated Rule Oriented Data-Management System (10:10) -
http://www.youtube.com/watch?v=QwZTGzNJCnc[+http://www.youtube.com/watch?v=QwZTGzNJCnc+]

Policy Based Preservation Environments (iRODS) (51:05) -
http://www.youtube.com/watch?v=SYqEVgdtnes[+http://www.youtube.com/watch?v=SYqEVgdtnes+]

iDrop Suite Overview, Part 1 (8:31) -
http://www.youtube.com/watch?v=YhciVQCZuBY[+http://www.youtube.com/watch?v=YhciVQCZuBY+]

iDrop Suite Overview, Part 2 (7:22) -
http://www.youtube.com/watch?v=1pu_EU3rmkU[+http://www.youtube.com/watch?v=1pu_EU3rmkU+]

Large Scale Storage for Data Intensive Science at KIT (28:30) -
http://www.youtube.com/watch?v=Cqxepa999Jc[+http://www.youtube.com/watch?v=Cqxepa999Jc+]

Extensions
~~~~~~~~~~

In addition to the built-in functionality, there are many extensions including
features, interfaces and drivers that increase its functionality via
third-party software.  A list of the available extensions can be found at:

https://wiki.irods.org/index.php/Extensions[+https://wiki.irods.org/index.php/Extensions+]




Obtaining and Installing
------------------------

Source and binary distributions are available at:

https://irods.org/download/[+https://irods.org/download/+]

Installation instructions are found at:

https://wiki.irods.org/index.php/Installation[+https://wiki.irods.org/index.php/Installation+]

Compiling the Source Distribution
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The source distribution is located on GitHub at:

https://github.com/irods/irods[+https://github.com/irods/irods+]

and can be downloaded via the command:

-----
su
cd /var/lib
git clone https://github.com/irods/irods.git
-----

As of this writing, this must be done in the +/var/lib+ directory.

After it has been downloaded into the directory +irods+, it is
compiled via:

-----
./packaging/build.sh icat postgres
./packaging/build.sh icommands
./packaging/build.sh resource
-----

The options for +build.sh+ are obtained by running it with no
arguments:

-----
+------------------------------------+
| RENCI iRODS Build Script           |
+------------------------------------+
Tue Apr 15 13:21:29 CDT 2014




Usage: build.sh [OPTIONS] <serverType> [databaseType]
Usage: build.sh docs
Usage: build.sh clean

Options:
-c      Build with coverage support (gcov)
-h      Show this help
-r      Build a release package (no debugging information, optimized)
-s      Skip compilation of iRODS source
-p      Portable option, ignores OS and builds a tar.gz

Long Options:
--run-in-place    Build server for in-place execution (not recommended)

Examples:
build.sh icat postgres
build.sh resource
build.sh -s icat postgres
build.sh -s resource
-----

Installing the RPM Files Just Built
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

First, the +irods-icat+ package:

-----
cd build
error: Failed dependencies:
	libcurl.so.4()(64bit) is needed by irods-icat-4.0.1-0.x86_64
rpm -ivh --nodeps irods-icat-4.0.1-64bit-centos5.rpm
Preparing...                ########################################### [100%]
Creating Service Group and Account: irods at /var/lib/irods 
   1:irods-icat             ########################################### [100%]

=======================================================================

Welcome to iRODS.

This installation of an iCAT server is currently incomplete and
needs a database plugin to be installed and configured before
it can be started and used.

Please consult the manual for further instructions.

=======================================================================
-----

Next, the PostgreSQL database plugin:

-----
rpm -ivh irods-database-plugin-postgres-1.0-centos5.rpm 
Preparing...                ########################################### [100%]
   1:irods-database-plugin-p########################################### [100%]

=======================================================================

iRODS Postgres Database Plugin installation was successful.

To configure this plugin, the following prerequisites need to be met:
 - an existing database user (to be used by the iRODS server)
 - an existing database (to be used as the iCAT catalog)
 - permissions for existing user on existing database

Please switch to the irods user:
  $ sudo su - irods

And run the following setup script:
  irods@hostname:~/ $ ./packaging/setup_database.sh

=======================================================================
-----

Now, obey the instructions:

-----
su - irods
-----

Installing RPM Files
~~~~~~~~~~~~~~~~~~~~

The +RPM_INSTALLATION_HOWTO.txt+ file at:

ftp://ftp.renci.org/pub/irods/releases/4.0.0/[+ftp://ftp.renci.org/pub/irods/releases/4.0.0/+]

tell us what we need to do before we starting installing the RPMs.

-----
1.  Yum Install Required Dependencies ::

   -- Note - names may change slightly between different OS versions, which can be determined by 'yum search package-name'

      postgresql
      postgresql-server
      unixODBC
      perl
      authd

      AND
      
      postgresql-odbc  (could also be postgresqlXX-odbc)
       - also needs to be installed, but this is not declared in the RPM due to issues with versioning resolution
-----

On barataria:  All packages already installed via checking via +rpm -q+.

-----
2.  Start Postgres Server and Initialize Database Tables ::

      CentOS 5.x :: sudo /sbin/service postgresql start
      CentOS 6.x :: sudo /sbin/service postgresql initdb; sudo /sbin/service postgresql start
      SUSE11     :: sudo /usr/sbin/rcpostgresql start
      OpenSUSE12 :: sudo /usr/sbin/rcpostgresql start

-----

On barataria:  PostgreSQL server already initialized and started.  Checked
with +/etc/init.d/postgresql status+.

-----      
3.  Modify authd config file for xinetd.d ::

      vim /etc/xinetd.d/auth

    Remove the '-E' command line argument for auth ::

      changing :
        [ server_args = -t60 --xerror --os -E ]
      to :
        [ server_args = -t60 --xerror --os ]
-----

On barataria:  The +-E+ command line argument was already gone.

-----
4.  Set the proper runlevel for authd ::

      sudo /sbin/chkconfig --level=3 auth on
-----

On barataria:  Entered command +/sbin/chkconfig --level=3 auth on+.

-----
5.  Restart xinetd

      sudo /etc/init.d/xinetd restart
-----

On barataria:  Entered command +/etc/init.d/xinetd restart+.

-----
6.  Open your firewall, if necessary, to let in iRODS ::

      Add the following to your /etc/sysconfig/iptables:

        -A INPUT -m state --state NEW -m tcp -p tcp --dport 1247 -j ACCEPT
        -A INPUT -m state --state NEW -m tcp -p tcp --dport 20000:20199 -j ACCEPT
        -A INPUT -m state --state NEW -m udp -p udp --dport 20000:20199 -j ACCEPT

      Restart the firewall:

        sudo service iptables restart
-----

On barataria:  Not done yet.

-----
7.  Install the iRODS RPM ::

      rpm -i irods-XXX.rpm
-----

Now we can start installing the RPMs on barataria.  They are
located in:

-----
/home/baum/IRODS
-----

irods-icat
^^^^^^^^^^

The irods-icat RPM package installs a service account and group named +irods+
and the iRODS binaries.

Running:

-----
rpm -ivh irods-icat-4.0.0-64bit-centos5.rpm
-----

gives:

-----
Preparing...                ########################################### [100%]
Creating Service Group and Account: irods at /var/lib/irods
   1:irods-icat             ########################################### [100%]

=======================================================================

Welcome to iRODS.

This installation of an iCAT server is currently incomplete and
needs a database plugin to be installed and configured before
it can be started and used.

Please consult the manual for further instructions.

=======================================================================
-----


irods-runtime
^^^^^^^^^^^^^

Running:

-----
rpm -ivh irods-runtime-4.0.0-64bit-centos5.rpm
-----

gives:

-----
Preparing...                ########################################### [100%]
   1:irods-runtime          ########################################### [100%]
-----

irods-resource
^^^^^^^^^^^^^^

The irods-resource RPM installs a service acccount and group named +irods+ and
the iRODS binaries.

Running:

-----
rpm -ivh irods-resource-4.0.0-64bit-centos5.rpm
-----

gives:

-----
Preparing...                ########################################### [100%]
	file /etc/irods/irods.config from install of irods-resource-4.0.0-0.x86_64 conflicts with file from package irods-icat-4.0.0-0.x86_64
	file /var/lib/irods/iRODS/config/config.mk from install of irods-resource-4.0.0-0.x86_64 conflicts with file from package irods-icat-4.0.0-0.x86_64
	file /var/lib/irods/iRODS/server/bin/irodsAgent from install of irods-resource-4.0.0-0.x86_64 conflicts with file from package irods-icat-4.0.0-0.x86_64
	file /var/lib/irods/iRODS/server/bin/irodsReServer from install of irods-resource-4.0.0-0.x86_64 conflicts with file from package irods-icat-4.0.0-0.x86_64
	file /var/lib/irods/iRODS/server/bin/irodsServer from install of irods-resource-4.0.0-0.x86_64 conflicts with file from package irods-icat-4.0.0-0.x86_64
-----

Moving on the force things we get:

-----
[root@barataria IRODS]# rpm -ivh --force irods-resource-4.0.0-64bit-centos5.rpm 
Preparing...                ########################################### [100%]
Creating Service Group and Account: irods at /var/lib/irods 
ERROR :: Please delete the existing Service Group irods before proceeding.
error: %pre(irods-resource-4.0.0-0.x86_64) scriptlet failed, exit status 1
error:   install: %pre scriptlet failed (2), skipping irods-resource-4.0.0-0
-----

We can't just delete the group without deleting the user, which
also deletes the group.  This is done via:

-----
/usr/sbin/userdel irods
-----

after which - upon trying the RPM again - we obtain:

-----
Preparing...                ########################################### [100%]
Creating Service Group and Account: irods at /var/lib/irods 
   1:irods-resource         ########################################### [100%]

=======================================================================

Welcome to iRODS.

This installation of a resource server is currently incomplete and
needs the following steps executed as the service account "irods":

  sudo su - irods

As the service account user, executing the following script will
prompt for necessary iRODS iCAT server information and then
populate your irods.config accordingly:

  ./packaging/setup_resource.sh

This will result in a running resource server with a default
resource named with your hostname concatenated with "Resource"
and a local vault in ~/iRODS/Vault.

Please consult the manual for further configuration details.

=======================================================================
-----

irods-icommands
^^^^^^^^^^^^^^^

-----
rpm -ivh irods-icommands-4.0.0-64bit-centos5.rpm
-----

on barataria gives:

-----
Preparing...                ########################################### [100%]
   1:irods-icommands        ########################################### [100%]
###########################################################
#
# The iCommands have been installed into your path.
# 
# They require your environment to be configured
# for communication with an iRODS server.
#
# Place the following configuration information into
# your .irodsEnv file and edit as appropriate:
#
#    ~/.irods/.irodsEnv
#
###########################################################

# iRODS server host name:
irodsHost 'FULLY.QUALIFIED.DOMAIN.NAME'
# iRODS server port number:
irodsPort 1247
# Default storage resource name:
irodsDefResource 'demoResc'
# Home directory in iRODS:
irodsHome '/tempZone/home/USERNAME'
# Current directory in iRODS:
irodsCwd '/tempZone/home/USERNAME'
# Account name:
irodsUserName 'USERNAME'
# Zone:
irodsZone 'tempZone'
# Enable Advanced Client-Server negotiation:
irodsClientServerNegotiation 'request_server_negotiation'
# Client-Server connection policy:
irodsClientServerPolicy 'CS_NEG_REFUSE'
# Client-Server Encryption Key Size In Bytes:
irodsEncryptionKeySize '32'
# Client-Server Encryption Salt Size In Bytes:
irodsEncryptionSaltSize '8'
# Client-Server Encryption Number of Hash Rounds:
irodsEncryptionNumHashRounds '16'
# Client-Server Encryption Algorithm:
irodsEncryptionAlgorithm 'AES-256-CBC'
-----

irods-dev
^^^^^^^^^

Running:

-----
rpm -ivh irods-dev-4.0.0-64bit-centos5.rpm
-----

gives:

-----
Preparing...                ########################################### [100%]
   1:irods-dev              ########################################### [100%]
-----

irods-database-plugin-postgres
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Running:

-----
rpm -ivh irods-database-plugin-postgres-1.0-centos5.rpm
-----

gives:

-----
Preparing...                ########################################### [100%]
   1:irods-database-plugin-p########################################### [100%]

=======================================================================

iRODS Postgres Database Plugin installation was successful.

To configure this plugin, the following prerequisites need to be met:
 - an existing database user (to be used by the iRODS server)
 - an existing database (to be used as the iCAT catalog)
 - permissions for existing user on existing database

Please run the following setup script as the irods user:
  ./packaging/setup_database.sh

=======================================================================
-----

Preparing PostgreSQL for iRODS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A database and a user must first be created from within PostgreSQL.

-----
su
su - postgres
-bash-3.2$ createdb icat
CREATE DATABASE
-bash-3.2$ psql
Welcome to psql 8.1.23, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help with psql commands
       \g or terminate with semicolon to execute query
       \q to quit

postgres=# create database icat;
CREATE DATABASE

postgres=# create user irods;
postgres=# select * from "pg_user";
 usename  | usesysid | usecreatedb | usesuper | usecatupd |  passwd  | valuntil | useconfig 
          |          |             |          |           |          |          |
 postgres |       10 | t           | t        | t         | ******** |          | 
 irods    |    16385 | f           | f        | f         | ******** |          | 
(2 rows)


postgres=# \l
        List of databases
   Name    |  Owner   | Encoding 
           +          +
 icat      | postgres | UTF8
 postgres  | postgres | UTF8
 template0 | postgres | UTF8
 template1 | postgres | UTF8
(4 rows)

postgres=# alter database icat owner to irods;
ALTER DATABASE
postgres=# \l
        List of databases
   Name    |  Owner   | Encoding 
           +          +
 icat      | irods    | UTF8
 postgres  | postgres | UTF8
 template0 | postgres | UTF8
 template1 | postgres | UTF8
(4 rows)

icat=# grant all on database icat to irods
GRANT

icat=# alter user irods with password 'g*';
icat=# alter user irods valid until 'infinity';

postgres=# \q
exit
-----

Next set up iRODS by running +setup_database.sh+, which is:

The Bash Script +setup_database.sh+
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Next set up iRODS by running +setup_database.sh+, which is:

[source,bash]
-----
#!/bin/bash -e

DATABASETYPE="postgres"
DEFAULT_DATABASEPORT="5432"

# config
IRODS_CONFIG_FILE="/etc/irods/irods.config"
SETUP_DATABASE_FLAG="/tmp/$USER/setup_database.flag"

# get into the irods user home directory
DETECTEDDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd $DETECTEDDIR/../

# get temp file from prior run, if it exists
mkdir -p /tmp/$USER
if [ -f $SETUP_DATABASE_FLAG ] ; then
    # have run this before, read the existing config file
    DATABASEHOSTORIP=`grep "DATABASE_HOST =" $IRODS_CONFIG_FILE | awk -F\' '{print $2}'`
    DATABASEPORT=`grep "DATABASE_PORT =" $IRODS_CONFIG_FILE | awk -F\' '{print $2}'`
    DATABASENAME=`grep "DB_NAME =" $IRODS_CONFIG_FILE | awk -F\' '{print $2}'`
    DATABASEUSER=`grep "DATABASE_USER =" $IRODS_CONFIG_FILE | awk -F\' '{print $2}'`
    STATUS="loop"
else
    # no temp file, this is the first run
    STATUS="firstpass"
fi

echo "==================================================================="
echo ""
echo "You are installing an iRODS database plugin."
echo ""
echo "The iRODS server cannot be started until its database"
echo "has been properly configured."
echo ""
while [ "$STATUS" != "complete" ] ; do

  # set default values from an earlier loop
  if [ "$STATUS" != "firstpass" ] ; then
    LASTDATABASEHOSTORIP=$DATABASEHOSTORIP
    LASTDATABASEPORT=$DATABASEPORT
    LASTDATABASENAME=$DATABASENAME
    LASTDATABASEUSER=$DATABASEUSER
  fi

  # get host
  echo -n "Database server's hostname or IP address"
  if [ "$LASTDATABASEHOSTORIP" ] ; then echo -n " [$LASTDATABASEHOSTORIP]"; fi
  echo -n ": "
  read DATABASEHOSTORIP
  if [ "$DATABASEHOSTORIP" == "" ] ; then
    if [ "$LASTDATABASEHOSTORIP" ] ; then DATABASEHOSTORIP=$LASTDATABASEHOSTORIP; fi
  fi
  # strip all forward slashes
  DATABASEHOSTORIP=`echo "${DATABASEHOSTORIP}" | sed -e "s/\///g"`
  echo ""

  # get port
  echo -n "Database server's port"
  if [ "$LASTDATABASEPORT" ] ; then
    echo -n " [$LASTDATABASEPORT]"
  else
    echo -n " [$DEFAULT_DATABASEPORT]"
  fi
  echo -n ": "
  read DATABASEPORT
  if [ "$DATABASEPORT" == "" ] ; then
    if [ "$LASTDATABASEPORT" ] ; then
      DATABASEPORT=$LASTDATABASEPORT
    else
      DATABASEPORT=$DEFAULT_DATABASEPORT
    fi
  fi
  # strip all forward slashes
  DATABASEPORT=`echo "${DATABASEPORT}" | sed -e "s/\///g"`
  echo ""

  # get the db name
  echo -n "Database name"
  if [ "$LASTDATABASENAME" ] ; then
    echo -n " [$LASTDATABASENAME]"
  else
    echo -n " [ICAT]"
  fi
  echo -n ": "
  read DATABASENAME
  if [ "$DATABASENAME" == "" ] ; then
    if [ "$LASTDATABASENAME" ] ; then
      DATABASENAME=$LASTDATABASENAME
    else
      DATABASENAME="ICAT"
    fi
  fi
  # strip all forward slashes
  DATABASENAME=`echo "${DATABASENAME}" | sed -e "s/\///g"`
  echo ""

  # get database user
  echo -n "Database username"
  if [ "$LASTDATABASEUSER" ] ; then
    echo -n " [$LASTDATABASEUSER]"
  else
    echo -n " [irods]"
  fi
  echo -n ": "
  read DATABASEUSER
  if [ "$DATABASEUSER" == "" ] ; then
    if [ "$LASTDATABASEUSER" ] ; then
      DATABASEUSER=$LASTDATABASEUSER
    else
      DATABASEUSER=irods
    fi
  fi
  # strip all forward slashes
  ADMINUSER=`echo "${DATABASEUSER}" | sed -e "s/\///g"`
  echo ""

  echo -n "Database password: "
  # get db password, without showing on screen
  read -s DATABASEPASSWORD
  echo ""
  echo ""

  # confirm
  echo "-------------------------------------------"
  echo "Database Type:     $DATABASETYPE"
  echo "Hostname or IP:    $DATABASEHOSTORIP"
  echo "Database Port:     $DATABASEPORT"
  echo "Database Name:     $DATABASENAME"
  echo "Database User:     $DATABASEUSER"
  echo "Database Password: Not Shown"
  echo "-------------------------------------------"
  echo -n "Please confirm these settings [yes]: "
  read CONFIRM
  if [ "$CONFIRM" == "" -o "$CONFIRM" == "y" -o "$CONFIRM" == "Y" -o "$CONFIRM" == "yes" ]; then
    STATUS="complete"
  else
    STATUS="loop"
  fi
  echo ""
  echo ""

done
touch $SETUP_DATABASE_FLAG
echo "==================================================================="

IRODS_CONFIG_TEMPFILE="/tmp/$USER/tmp.irods.config"
echo "Updating irods.config..."
sed -e "/^\$DATABASE_TYPE/s/^.*$/\$DATABASE_TYPE = '$DATABASETYPE';/" $IRODS_CONFIG_FILE > $IRODS_CONFIG_TEMPFILE
mv $IRODS_CONFIG_TEMPFILE $IRODS_CONFIG_FILE
sed -e "/^\$DATABASE_HOST/s/^.*$/\$DATABASE_HOST = '$DATABASEHOSTORIP';/" $IRODS_CONFIG_FILE > $IRODS_CONFIG_TEMPFILE
mv $IRODS_CONFIG_TEMPFILE $IRODS_CONFIG_FILE
sed -e "/^\$DATABASE_PORT/s/^.*$/\$DATABASE_PORT = '$DATABASEPORT';/" $IRODS_CONFIG_FILE > $IRODS_CONFIG_TEMPFILE
mv $IRODS_CONFIG_TEMPFILE $IRODS_CONFIG_FILE
sed -e "/^\$DATABASE_ADMIN_NAME/s/^.*$/\$DATABASE_ADMIN_NAME = '$DATABASEUSER';/" $IRODS_CONFIG_FILE > $IRODS_CONFIG_TEMPFILE
mv $IRODS_CONFIG_TEMPFILE $IRODS_CONFIG_FILE
sed -e "/^\$DB_NAME/s/^.*$/\$DB_NAME = '$DATABASENAME';/" $IRODS_CONFIG_FILE > $IRODS_CONFIG_TEMPFILE
mv $IRODS_CONFIG_TEMPFILE $IRODS_CONFIG_FILE

# =-=-=-=-=-=-=-
# update database flavor
if [ -e /etc/irods/server.config ] ;  then 
    server_config="/etc/irods/server.config"
else
    server_config="./iRODS/server/config/server.config"
fi

echo ""
echo "# configuration of icat database plugin - e.g. postgres, mysql, or oracle" >> $server_config
echo "catalog_database_type $DATABASETYPE" >> $server_config 
echo ""

# =-=-=-=-=-=-=-
# run irods_setup.pl
cd iRODS
./irodsctl stop
echo "Running irods_setup.pl..."
perl ./scripts/perl/irods_setup.pl $DATABASETYPE $DATABASEHOSTORIP $DATABASEPORT $DATABASEUSER $DATABASEPASSWORD
-----

At the end of this bash script, the following Perl command is run to set up
the PostgreSQL database:

-----
perl ./scripts/perl/irods_setup.pl $DATABASETYPE $DATABASEHOSTORIP $DATABASEPORT $DATABASEUSER $DATABASEPASSWORD
-----

But running this by itself still doesn't work.
The script stalls right before it's supposed to run the SQL creation files:

-----
/var/lib/irods/iRODS/server/icat/src/icatSysTables.sql
/var/lib/irods/iRODS/server/icat/src/icatSysInserts.sql
-----

So we'll just run the commands within those files by hand.  Be sure
to become the user +irods+ before this is done.
Even after creating the tables we still get the "could not list tables"
error, so we go into the appropriate section of:

-----
/var/lib/irods/iRODS/scripts/perl/irods_setup.pl
-----

to find:

[source,perl]
-----
        # Create the tables.
        #       The iCAT SQL files issue a number of instructions to
        #       create tables and initialize state.  If this script
        #       has been run before, then these tables will already be
        #       there.  Running the SQL instructions a second time
        #       will corrupt the database.  So, we need to check first.
        printStatus( "Creating iCAT tables...\n" );
        printLog( "Creating iCAT tables...\n" );

        my $tables = listDatabaseTables( $DB_NAME );
        if ( ! defined( $tables ) )
        {
                printError( "\nInstall problem:\n" );
                printError( "    Could not list tables in the database:\n" );
                printError( "        ", $output );
                printLog( "\nSQL failed:\n" );
                printLog( "    ", $output );
                cleanAndExit( 1 );
        }
-----

where +listDatabaseTables+ is the subroutine:

[source,perl]
-----
sub listDatabaseTables()
{
        my ($dbname) = @_;

        # Postgres
        if ( $DATABASE_TYPE eq "postgres" )
        {
                return Postgres_ListDatabaseTables( $dbname );
        }

        # Oracle
        if ( $DATABASE_TYPE eq "oracle" )
        {
                return Oracle_ListDatabaseTables( $dbname );
        }

        # MySQL
        if ( $DATABASE_TYPE eq "mysql" )
        {
                return MySQL_ListDatabaseTables( $dbname );
        }

        # Empty
        if ( $DATABASE_TYPE eq "" )
        {
                printStatus( "    Skipped.  No database to access.\n" );
                printLog( "    Skipped.  No database to access.\n" );
                return undef;
        }

        # Otherwise skip it.
        printStatus( "    Skipped.  Unsupported database type:  $DATABASE_TYPE.\n" );
        printLog( "    Skipped.  Unsupported database type:  $DATABASE_TYPE.\n" );
        return undef;
}
-----

and +Postgres_ListDatabaseTables+ is the subroutine:

[source,perl]
-----
sub Postgres_ListDatabaseTables($)
{
        my ($dbname) = @_;

        # Using psql, issue the \d command for a list of tables.
        my $tmpSql = createTempFilePath( "sql" );
        printToFile( $tmpSql, "\n\\d\n" );
        ($status,$output) = execute_sql( $dbname, $tmpSql );
        unlink( $tmpSql );

        if ( $status == 0 )
        {
                return $output;
        }
        printLog( "    Cannot get list of tables from Postgres:\n" );
        printLog( "        ", $output );
        return undef;
}
-----


Next...

-----
su - irods
-bash-3.2$ ./packaging/setup_database.sh 
===================================================================

You are installing an iRODS database plugin.

The iRODS server cannot be started until its database
has been properly configured.

Database server's hostname or IP address [barataria.tamu.edu]: 

Database server's port [5432]: 

Database name [icat]: 

Database username [irods]: 

Database password: 

-------------------------------------------
Database Type:     postgres
Hostname or IP:    barataria.tamu.edu
Database Port:     5432
Database Name:     icat
Database User:     irods
Database Password: Not Shown
-------------------------------------------
Please confirm these settings [yes]: 


===================================================================
Updating irods.config...


Stopping iRODS server...
Found 0 processes:
        There are no iRODS servers running.
Running irods_setup.pl...

Step 1 of 5:  Configuring database user...
    Updating user's .pgpass...
        Skipped.  File already uptodate.

Step 2 of 5:  Creating database and tables...
    Checking whether iCAT database exists...
        Skipped creating iCAT database, it already exists.
    Updating user's .odbc.ini...
    Creating iCAT tables...

Install problem:
    Could not list tables in the database:
        Found 0 processes:
        There are no iRODS servers running.

Abort.
-----

A peek inside +setup_database.sh+ shows that it calls the Perl script
+irods_setup.pl+ near the end.  Looking inside that file reveals that several
packages are required, and that our current version of Perl lacks at
least one of them.  We remedy this via the following commands
under the CPAN shell.

-----
su
perl -MCPAN -e shell
cpan[*]> install File::Spec
cpan[*]> force install File::Copy
-----

Since I had an older version of Perl, this installed the latest version.  Thus
we need to exist the CPAN shell and re-enter to use the newer Perl version.

-----
cpan[*] exit
perl -MCPAN -e shell
cpan[*]> install File::Spec
File::Spec is up to date (3.40).
cpan[*]> install File::Copy
File::Copy is up to date (2.26).
-----

Checking the PostgreSQL Server With Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Using the Python package +psycopg+ that can be found at:

http://initd.org/psycopg/[+http://initd.org/psycopg/+]

Install it in the usual way, and then try the following:

-----
python2.7
Python 2.7.2 (default, Mar  1 2012, 21:28:11) 
[GCC 4.1.2 20080704 (Red Hat 4.1.2-51)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import psycopg2
>>> conn = psycopg2.connect("dbname=icat user=irods")
>>> cur = conn.cursor()
>>> cur.execute("""SELECT datname from pg_database""")
>>> rows = cur.fetchall()
>>> print "\nShow me the databases:\n"

Show me the databases:

>>> for row in rows:
...     print "    ",row[0]
... 
     postgres
     template1
     template0
     icat
>>> 
-----


Starting the iCAT Server
~~~~~~~~~~~~~~~~~~~~~~~~

The iCAT server is started - via the instructions in the user manual - by
running the +setup_database.sh+ program as user +irods+.


-----
su
su - irods
-bash-3.2$ /var/lib/irods/packaging/setup_resource.sh 
===================================================================

You are installing an iRODS resource server.  Resource servers
cannot be started until they have been properly configured to
communicate with a live iCAT server.

iCAT server's hostname or IP address [barataria.tamu.edu]: barataria.tamu.edu

iCAT server's port [1247]: 1248

iCAT server's ZoneName [Twilight]: 

iRODS admin username [rods]: rods

-------------------------------------------
Hostname or IP:   barataria.tamu.edu
iCAT Port:        1248
iCAT Zone:        Twilight
Admin User:       rods
-------------------------------------------
Please confirm these settings [yes]: yes


===================================================================
Updating irods.config...
Running irods_setup.pl...

The following password will not be written to disk
or made visible to any process other than this setup script.

  iCAT server's admin username: rods
  iCAT server's admin password: 


Step 1 of 3:  Preparing to initialize...
    Stopping iRODS server...
Found 0 processes:
        There are no iRODS servers running.

Step 2 of 3:  Configuring iRODS server...
    Updating iRODS server.config...
    Running 'iinit' to enable server to server connections...
    Using ICAT-enabled server on 'barataria.tamu.edu'

Step 3 of 3:  Configuring iRODS user and starting server...
    Updating iRODS user's ~/.irods/.irodsEnv...
    Starting iRODS server...
Could not start iRODS server.
    Starting iRODS server...
iRODS server failed to start.


Install problem:
    Cannot start iRODS server.
Found 0 processes:
        There are no iRODS servers running.

Abort.
-----

Googling the string 

-----
Could not start iRODS server.
    Starting iRODS server...
iRODS server failed to start.
-----

finds the page:'

https://github.com/irods/irods/issues/2068[+https://github.com/irods/irods/issues/2068+]

wherein we discover that the +lib_mysqludf_preg+ functions must be installed
for the MySQL plugin to function correctly.  These can be found at:

https://github.com/mysqludf/lib_mysqludf_preg[+https://github.com/mysqludf/lib_mysqludf_preg+]

There we find a link to:

http://www.goodhumans.com/Misc/lib_mysqludf/[+http://www.goodhumans.com/Misc/lib_mysqludf/+]

from which we download +lib_mysqludf_preg-1.2-rc2.tar.gz+, and then:

-----
tar xzvf lib_mysqludf_preg-1.2-rc2.tar.gz
cd lib_mysqludf_preg-1.2-rc2
make distclean
./configure --with-mysql=/usr/bin/mysql_config
make
su
make install
/sbin/ldconfig
make installdb
/usr/bin/mysql -p <./uninstalldb.sql
Enter password:
if test -f .libs/lib_mysqludf_preg.dll; then  \
		/usr/bin/mysql -p <./installdb_win.sql; \
	else \
		/usr/bin/mysql -p <./installdb.sql;\
	fi
Enter password:
ERROR 1126 (HY000) at line 3: Can't open shared library 'lib_mysqludf_preg.so'
(errno: 22 /usr/local/lib/lib_mysqludf_preg.so: undefined symbol:
my_thread_stack_size)
make: *** [installdb] Error 1
-----

Googling for:

-----
/usr/local/lib/lib_mysqludf_preg.so: undefined symbol: my_thread_stack_size)
-----

finds the page:

https://github.com/mysqludf/lib_mysqludf_preg/issues/13[+https://github.com/mysqludf/lib_mysqludf_preg/issues/13+]

wherein we find we need to edit +preg_utils.c+ and comment out lines 131 and
132, i.e.

-----
        extern unsigned long my_thread_stack_size;
        thread_stack_size = my_thread_stack_size ;
-----

to be:

-----
        // extern unsigned long my_thread_stack_size;
        // thread_stack_size = my_thread_stack_size ;
-----

Going through the above procedure to compile and install the package finds
success this time, and we can check to see that it is installed via:

-----
mysql -uroot -p
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 2067
Server version: 5.0.95 Source distribution

Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> select name from mysql.func
    -> ;
+------------------------+
| name                   |
+------------------------+
| lib_mysqludf_preg_info | 
| preg_capture           | 
| preg_check             | 
| preg_position          | 
| preg_replace           | 
| preg_rlike             | 
+------------------------+
6 rows in set (0.00 sec)
-----




Configuration
-------------

Each user must configure a user environment via
setting various environment variables.  These can be set as either
UNIX environment variables or as a line in a text file called
the iRODS environment file.  If the UNIX variable are set, they
will override the environment file.
The environment file is located by default at:

-----
~/.irods/.irodsEnv
-----

although this can be overridden by setting the UNIX
environment variable +irodsEnvFile+.

Four settings are needed for the xref:icommands[+icommands+] to function.
These are:

* +irodsUserName+ - your iRODS username
* +irodsHost+ - an iRODS server host to which you will connect
* +irodsPort+ - the network port (TCP) to which the server is listening
* +irodsZone+ - the name of your home iRODS data grid or zone

The remainder of the +icommands+ environment variables are:

* +irodsHome+ - your iRODS Home collection
* +irodsCwd+ - your iRODS current working directory
* +irodsAuthScheme+ - set to xref:GSI[+GSI+] authentication with default
xref:password[password]
* +irodsDefResource+ - a default resource to use when storing
* +irodsServerDn+ - if set, and if using GSI authentication, this is the
server's distinguished name for mutual authentication
* +irodsLogLevel+ - the level of messages to log or display
* +irodsAuthFileName+ - the file that stores your scrambled password for
authentication
* +irodsProt+ - if set to +1+, this will select the XML protocol that will
cause the server and client to use XML for the session


Reference:
https://wiki.irods.org/index.php/user_environment[+https://wiki.irods.org/index.php/user_environment+]

Microservices
-------------

A microservice is a small, well-defined procedure/function that performs a
specific task.
Micro-services are developed and made available by system programmers and
application programmers and compiled into the iRODS server code. Users and
administrators can chain these micro-services to implement a larger
macro-level functionality that they want to use or provide for others.
These macro-level functionalities are called actions. By having more than one
chain of micro-services for an action, a system can have multiple ways of
performing the action. Using priorities and validation conditions, at
run-time, the system chooses the 'best' micro-service chain to be executed.
Further details can be found at:

https://wiki.irods.org/index.php/Micro-Services[+https://wiki.irods.org/index.php/Micro-Services+]

A complete list of available microservices is found at:

https://wiki.irods.org/doxygen/[+https://wiki.irods.org/doxygen/+]

Rules, the Rule Language, and the Rule Engine
---------------------------------------------

iRODS implements rules in a rule language that are enforced by a rule
engine.  This is an instantiation of a paradigm called *rule-oriented
programming (ROP)* wherein the capability of controlling functionality
rests more with users than system and application developers.
ROP can be seen as lego-block type programming with the building
blocks being *microservices*, small, well-defined procedures or
functions that perform specific tasks.  The microservices are developed
and made available by programmers, and users and administrators chain
the microservices to implement larger macro-level functionality they
wish to provide for others.  For example, separate microservices for
creating a collection, computing a checksum of that collection, and
replicating that collection can be combined into a macroservice or *action* for
collating and backing up a collection of files.

Rules
~~~~~

Rules are definitions of actions (or macro-level tasks) that need to be
performed by the server. These definitions are made in terms of micro-services
and other actions. The iRODS server has a built-in Rule Engine that interprets
rules and calls the underlying micro-services as needed. 

In the current implementation of iRODS the rules are stored in files in the
+server/config/reConfigs+ directory with an +.irb+ extension (2.5) or a +.re+
extension (3.0), which stands for iRODS Rule Base. There can be more than one
irb or re file. The set of irb or re files to be used is decided by the iRODS
administrator by setting values for the variable +reRuleSet+ in the
+server/config/server.config+ file. The administrator can include more than one
rule base file, by setting the value in a comma-separated manner. The files
will be read in the order they are given in the list (left-to-right) and the
rules are prioritized in the order they are read. By default, the rule base to
be used is set to the +core.irb+ or +core.re+ file. 

https://wiki.irods.org/index.php/Rules[+https://wiki.irods.org/index.php/Rules+]

Rule Language
~~~~~~~~~~~~~

The iRODS Rule Language is a language provided by iRODS to define policies and
actions in the system. The iRODS Rule Language is tightly integrated with
other components of iRODS. Many frequently used policies and actions can be
configured easily by writing simple rules, yet the language is flexible enough
to allow complex policies or actions to be defined. 

The syntax and grammar of the rule language are defined at:

https://wiki.irods.org/index.php/Rules[+https://wiki.irods.org/index.php/Rules+]

Recent updates and improvements to the language are explained at:

https://wiki.irods.org/index.php/Changes_and_Improvements_to_the_Rule_Language_and_the_Rule_Engine[+https://wiki.irods.org/index.php/Changes_and_Improvements_to_the_Rule_Language_and_the_Rule_Engine+]

Rule Engine
~~~~~~~~~~~

The Rule Engine is the interpreter of rules in the iRODS system.

https://wiki.irods.org/index.php/Rule_Engine[+https://wiki.irods.org/index.php/Rule_Engine+]

Tutorial
--------

An online tutorial is available at:

https://wiki.irods.org/index.php/Tutorial[+https://wiki.irods.org/index.php/Tutorial+]

[[icommands]]
Command-Line Interface
----------------------

The command-line interface for iRODS consists of various UNIX utilities for
interfacing with the system.
These are called +icommands+ and are divided into six general categories:

* xref:cl-unix[UNIX-like commands];
* xref:cl-metadata[metadata commands];
* xref:cl-info[informational commands];
* xref:cl-admin[administration commands];
* xref:cl-rules[rules and delayed execution commands]; and
* xref:cl-netcdf[NetCDF commands].

[[cl-unix]]
UNIX-like Commands
~~~~~~~~~~~~~~~~~~

[[iinit]]
+iinit+
^^^^^^^

Usage: +iinit [-ehvVl] [--ttl TimeToLive]+

Options:

-----
-e  echo the password as you enter it (normally there is no echo)
-l  list the iRODS environment variables (only)
-v  verbose
-V  Very verbose
--ttl ttl  set the password Time To Live (specified in hours)
          Run 'iinit -h --ttl' for more
-h  this help
-----

[[iput]]
+iput+
^^^^^^

Store a file into iRODS. If the destination data-object or collection are not
provided, the current iRODS directory and the input file name are used. 

Usage: +iput [-abfIkKPQrtTUvV] [-D dataType] [-N numThreads] [-n replNum] [-p
physicalPath] [-R resource] [-X restartFile] [--link] [--lfrestart
lfRestartFile] [--retries count] [--wlock] [--purgec] localSrcFile|localSrcDir
...  destDataObj|destColl+

Usage: +iput [-abfIkKPQtTUvV] [-D dataType] [-N numThreads] [-n replNum] [-p
physicalPath] [-R resource] [-X restartFile] [--link] [--lfrestart
lfRestartFile] [--retries count] [--wlock] [--purgec] localSrcFile+

where:

* +-X+ - specifies that the restart option is on and the operation is
restartable. The +restartFile+ input specifies a local file that contains the
restart information. If the +restartFile+ does not exist, it will be created
and used for recording subsequent restart information. If it exists and is
not empty, the restart information contained in this file will be used to
restart the operation. Note that the operation is not restarted
automatically when it failed. Another iput +-X+ run must be made to continue
from where it left off using the restart information. But the +-X+ option can
be used in conjunction with the +--retries+ option to automatically restart
the operation in case of failure. Also note that the restart operation only
works for uploading directories and the path input must be identical to the
one that generated the restart file. 

* +-lfrestart+ - specifies that the large file restart option is on and the
+lfRestartFile+ input specifies a local file that contains the restart
information. Currently, only files larger than 32 Mbytes will be restarted.
The +--lfrestart+ option can be used together with the +-X+ option to do large
file transfer restart as part of the overall directory upload restart. 

* +-f+ - used to overwrite an existing data-object, the copy in the
resource specified by the +-R+ option will be picked if it exists. Otherwise,
one of the copies in the other resources will be picked for the overwrite.
Note that a copy will not be made in the specified resource if a copy in the
specified resource does not already exist. The xref:irepl[+irepl+] command should be used to
make a replica of an existing copy. 

* +-I+ - specifies the redirection of the connection so that it can be
connected directly to the resource server. This option can improve the
performance of uploading a large number of small (<32 Mbytes) files. This
option is only effective if the source is a directory and the +-f+ option is not
used.

* +-Q+ - specifies the use of the RBUDP transfer mechanism which uses the UDP
protocol for data transfer. The UDP protocol is very efficient if the network
is very robust with few packet losses. Two environment variables -
+rbudpSendRate+ and +rbudpPackSize+ are used to tune the RBUDP data transfer.
+rbudpSendRate+ is used to throttle the send rate in kbits/sec. The default
+rbudpSendRate+ is 600,000. +rbudpPackSize+ is used to set the packet size. The
default +rbudpPackSize+ is 8192. The +-V+ option can be used to show the loss rate
of the transfer. If the loss rate is more than a few percent, the +rbudpSendRate+
should be reduced. 

* +-T+ - will renew the socket connection between the client and server after
10 minutes of connection. This gets around the problem of sockets getting
timed out by the server firewall as reported by some users. 

* +-b+ - specifies the bulk upload operation which can do up to 50 uploads at
a time to reduce overhead. If the +-b+ option is specified with the +-f+ option to
overwrite existing files, the operation will work only if there is no existing
copy at all or if there is an existing copy in the target resource. The
operation will fail if there are existing copies but not in the target
resource because this type of operation requires a replication operation and
bulk replication has not been implemented yet. The bulk option does work for
mounted collections which may represent the quickest way to upload a large
number of small files. 

Other options:

-----
-a  all - update all existing copies
-b  bulk upload to reduce overhead
-D  dataType - the data type string
-f  force - write data-object even it exists already; overwrite it
-I  redirect connection - redirect the connection to connect directly
      to the resource server.
-k  checksum - calculate a checksum on the data
-K  verify checksum - calculate and verify the checksum on the data
--link - ignore symlink.
-n  replNum  - the replica to be replaced, typically not needed
-N  numThreads - the number of threads to use for the transfer. A value of
      0 means no threading. By default (-N option not used) the server 
      decides the number of threads to use.
--purgec  Purge the staged cache copy after uploading an object to a
    COMPOUND resource
-p  physicalPath - the physical path of the uploaded file on the server 
-P  output the progress of the upload.
-Q  use RBUDP (datagram) protocol for the data transfer
-R  resource - specifies the resource to store to. This can also be specified
    in your environment or via a rule set up by the administrator.
-r  recursive - store the whole subdirectory
-T  renew socket connection after 10 minutes
-t  ticket - ticket (string) to use for ticket-based access
-v  verbose
-V  Very verbose
-X  restartFile - specifies that the restart option is on and the restartFile
      input specifies a local file that contains the restart information.
--retries count - Retry the iput in case of error. The 'count' input
      specifies the number of times to retry. It must be used with the
      -X option
--lfrestart lfRestartFile - specifies that the large file restart option is
      on and the lfRestartFile input specifies a local file that contains
      the restart information.
--wlock - use advisory write (exclusive) lock for the upload
--hash md5|sha256 - use the specified file hash type (checksum) instead of
      the default.  [The rest of this text printed via -h will indicate how
         your version was built: for example:
      This 'iput' is built without sha256 support
      so the '--hash' option is not available.
      See https://www.irods.org/index.php/File_Hashes for more. ]
-h  this help
-----

[[iget]]
+iget+
^^^^^^

Get data-objects or collections from irods space, either to the specified
local area or to the current working directory. 
If the destLocalFile is '-', the files read from the server will be written to
the standard output (stdout). Similar to the UNIX 'cat' command, multiple
source files can be specified. 

Usage: +iget [-fIKPQrUvVT] [-n replNumber] [-N numThreads] [-X restartFile] [-R resource] [--lfrestart lfRestartFile] [--retries count] [--purgec] [--rlock] srcDataObj|srcCollection ... destLocalFile|destLocalDir+

Usage: +iget [-fIKPQUvVT] [-n replNumber] [-N numThreads] [-X restartFile] [-R resource] [--lfrestart lfRestartFile] [--retries count] [--purgec] [--rlock] srcDataObj|srcCollection+

Usage: +iget [-fIKPQUvVT] [-n replNumber] [-N numThreads] [-X restartFile] [-R resource] [--lfrestart lfRestartFile] [--retries count] [--purgec] [--rlock] srcDataObj ... -+

where:

* +-X+ - specifies that the restart option is on and the operation is
restartable. The restartFile input specifies a local file that contains the
restart info. If the restartFile does not exist, it will be created and used
for recording subsequent restart info. If it exists and is not empty, the
restart info contained in this file will be used to restart the operation.
Note that the operation is not restarted automatically when it failed. Another
+iget -X+ run must be made to continue from where it left off using the restart
info. But the +-X+ option can be used in conjunction with the +--retries+ option
to automatically restart the operation in case of failure. Also note that the
restart operation only works for uploading directories and the path input must
be identical to the one that generated the restart file

* +--lfrestart+ - specifies that the large file restart option is on and
the +lfRestartFile+ input specifies a local file that contains the restart info.
Currently, only files larger than 32 Mbytes will be restarted. The +--lfrestart+
option can be used together with the +-X+ option to do large file transfer
restart as part of the overall collection download restart.

* +-Q+ - specifies the use of the RBUDP transfer mechanism which uses the
UDP protocol for data transfer. The UDP protocol is very efficient if the
network is very robust with few packet losses. Two environment variables -
+rbudpSendRate+ and +rbudpPackSize+ are used to tune the RBUDP data transfer.
+rbudpSendRate+ is used to throttle the send rate in kbits/sec. The default
+rbudpSendRate+ is 600,000. +rbudpPackSize+ is used to set the packet size. The
dafault +rbudpPackSize+ is 8192. The +-V+ option can be used to show the loss rate
of the transfer. If the lost rate is more than a few percent, the sendrate should be
reduced.

* +-T+ option will renew the socket connection between the client and server
after 10 minutes of connection. This gets around the problem of sockets
getting timed out by the firewall as reported by some users. 

Other options:

-----
-f  force - write local files even it they exist already (overwrite them)
-I  redirect connection - redirect the connection to connect directly
      to the best (determiined by the first 10 data objects in the input
      collection) resource server.
-K  verify the checksum
-n  replNumber - retrieve the copy with the specified replica number 
-N  numThreads - the number of thread to use for the transfer. A value of
      0 means no threading. By default (-N option not used) the server 
      decides the number of threads to use.
--purgec  Purge the staged cache copy after downloading a COMPOUND object
-P  output the progress of the download.
-r  recursive - retrieve subcollections
-R  resource - the preferred resource
-T  renew socket connection after 10 minutes
-Q  use RBUDP (datagram) protocol for the data transfer
-v  verbose
-V  Very verbose
    restartFile input specifies a local file that contains the restart info.
-X  restartFile - specifies that the restart option is on and the
    restartFile input specifies a local file that contains the restart info.
--retries count - Retry the iget in case of error. The 'count' input
    specifies the number of times to retry. It must be used with the
    -X option
--lfrestart lfRestartFile - specifies that the large file restart option is
     on and the lfRestartFile input specifies a local file that contains
     the restart info.
-t  ticket - ticket (string) to use for ticket-based access.
--rlock - use advisory read lock for the download
-h  this help
-----

[[imkdir]]
+imkdir+
^^^^^^^^

Usage: +imkdir [-phvV] collection ...+

Create one or more new collections.

Options are:

-----
-p  make parent directories as needed
-v  verbose
-V  Very verbose
-h  this help
-----

[[ichmod]]
+ichmod+
^^^^^^^^

Usage: +ichmod [-rhvVM] null|read|write|own userOrGroup dataObj|Collection
...+

Usage: +ichmod [-rhvVM] inherit Collection ...+

Usage: +ichmod [-rhvVM] noinherit Collection ...+

Usage: +ichmod [-R] null|read|write|own userOrGroup DBResource+

Modify access to dataObjects (iRODS files), collections (directories), and
Database Resources.

When you store a file, you are the owner and have full control - you can read,
write or delete it and, by default, no one else can. With +chmod+ you can give
access to other users or groups, either just read access, or read and write,
or full ownership. You can only give (or remove) access to others if you own
the file yourself. But if you give +own+ to someone else, they can also give
(and remove) access to others.

You can remove access by changing the access to +null+.

Multiple paths can be entered on the command line.

If the entered path is a collection, then the access permissions to that
collection will be modified. For example, you can give write access to a user
or group so they can store files into one of your collections. Access
permissions on collections and data-objects are displayed via the xref:ils[+ils+] +-A+
option. All users can read all collections (i.e. see data-object names
within), unless the administrator has enabled the strict ACL policy (via the
+acAclPolicy+ rule).

The inherit/noinherit form sets or clears the inheritance attribute of one or
more collections. When collections have this attribute set, new dataObjects
and collections added to the collection inherit the access permisions (ACLs)
of the collection. xref:ils[+ils+] +-A+ displays ACLs and the inheritance status.

If you are the irods administrator, you can include the +-M+ option to run in
administrator mode and set the permissions on the collection(s) and/or
data-objects as if you were the owner. This is more convenient than aliasing
as the user.

To execute a Database Object (DBO) on a Database Resource (DBR), users need to
have access permissions (read, write, or better). The admin or owner can
use xref:ichmod[+ichmod+] to set these. See xref:ilsresc[+ilsresc+] for listing these. See the Database
Resources page on the irods web site for more information.

Like Unix, if you remove your own access to an object (null), you will not
be able to read it, but you can restore access via another +ichmod+ because
for +ichmod+, you are still the owner. 

Options:

-----
-r  recursive - set the access level for all dataObjects
            in the entered collection and subCollections under it
-v  verbose
-V  Very verbose
-R  Resource (Database Resource)
-M  Admin Mode
-h  this help
-----

[[icp]]
+icp+
^^^^^
Copies an irods data-object (file) or collection (directory) to another
data-object or collection.

Usage: +icp [-fkKPQrTvV] [-N numThreads] [-p physicalPath] [-R resource] -X restartFile] srcDataObj|srcColl ... destDataObj|destColl+

where:

* +-Q+ - specifies the use of the RBUDP transfer mechanism which uses the UDP protocol for data transfer. The UDP protocol is very efficient if the network is very robust with few packet losses. Two environment variables - +rbudpSendRate+ and +rbudpPackSize+ are used to tune the RBUDP data transfer. +rbudpSendRate+ is used to throttle the send rate in kbits/sec. The default +rbudpSendRate+ is 600,000. +rbudpPackSize+ is used to set the packet size. The dafault +rbudpPackSize+ is 8192.

* +-X+ - specifies that the restart option is on and the +restartFile+ input specifies a local file that contains the restart info. If the +restartFile+ does not exist, it will be created and used for recording subsequent restart info. If it exists and is not empty, the restart info contained in this file will be used for restarting the operation. Note that the restart operation only works for uploading directories and the path input must be identical to the one that generated the restart file

* +-T+ - will renew the socket connection between the client and server after 10 minutes of connection. This gets around the problem of sockets getting timed out by the firewall as reported by some users. 

[[irm]]
+irm+
^^^^^

Remove one or more data-object or collection from iRODS space. By default, the
data-objects are moved to the trash collection (+/myZone/trash+) unless either
the +-f+ option or the +-n+ option is used. 

Usage: +irm [-rUfvVh] [-n replNum] [--empty] dataObj|collection ...+

where:

* +-U+ - allows the unregistering of the data object or collection without
deleting the physical file. Normally, a normal user cannot unregister a data
object if the physical file is located in a resource vault. The
+acNoChkFilePathPerm+ rule allows this check to be bypassed. 

* +-R+ - there is no +-R+ option (remove replica from a named resource) at this
time. Please use xref:itrim[+itrim+] (with the +-S+ option) instead. 

The xref:irmtrash[+irmtrash+] command should be used to delete data-objects in the trash
collection. 

Other options:

-------
-f  force - Immediate removal of data-objects without putting them in trash .
-n  replNum  - the replica to remove; if not specified remove all replicas.
    This option is applicable only to the removal of data object and
    will be ignored for collection removal.
-r  recursive - remove the whole subtree; the collection, all data-objects
    in the collection, and any subcollections and sub-data-objects in the
    collection.
-U  unregister the file or collection
-v  verbose
-V  Very verbose
--empty  If the file to be removed is a bundle file (generated with iphybun)
    remove it only if all the subfiles of the bundle have been removed.
-h  this help
-------

[[ils]]
+ils+
^^^^^

Display data Objects and collections stored in irods.

Usage: +ils [-ArlLv] dataObj|collection ... Usage : ils --bundle [-r] dataObj|collection ...+

Options:

-----
-A  ACL (access control list) and inheritance format
-l  long format
-L  very long format
-r  recursive - show subcollections
-t  ticket - use a read (or write) ticket to access collection information
-v  verbose
-V  Very verbose
-h  this help
--bundle - list the subfiles in the bundle file (usually stored in the
    +/myZone/bundle+ collection) created by xref:iphybun[+iphybun+] command.
-----

[[ipwd]]
+ipwd+
^^^^^^

Shows your iRODS Current Working Directory. 

Usage: +ipwd [-vVh]+

Options:

-----
-v  verbose
-V  very verbose
-h  this help
-----

[[icd]]
+icd+
^^^^^

Changes iRODS the current working directory (collection).

Usage: +icd [-vh] [directory]+

If no directory is entered, the cwd is set back to your home directory as
defined in your xref:rodsEnv[+.rodsEnv+] file. Like the unix +cd+, +..+ will move up one level
and +/name+ starts at the root. 

[[irepl]]
+irepl+
^^^^^^^

Replicate a file in iRODS to another storage resource. 

Usage: +irepl [-aBMPQrTvV] [-n replNum] [-R destResource] [-S srcResource] [-G resourceGroup] [-N numThreads] [-X restartFile] [--purgec] [--rlock] dataObj|collection ...+

where:

* +-Q+ - specifies the use of the RBUDP transfer mechanism which uses the
UDP protocol for data transfer. The UDP protocol is very efficient if the
network is very robust with few packet losses. Two environment variables -
+rbudpSendRate+ and +rbudpPackSize+ are used to tune the RBUDP data transfer.
+rbudpSendRate+ is used to throttle the send rate in kbits/sec. The default
+rbudpSendRate+ is 600,000. +rbudpPackSize+ is used to set the packet size. The
dafault +rbudpPackSize+ is 8192.

* +-X+ - specifies that the restart option is on and the +restartFile+
input specifies a local file that contains the restart info. If the
+restartFile+ does not exist, it will be created and used for recording
subsequent restart info. If it exists and is not empty, the restart info
contained in this file will be used for restarting the operation. Note that
the restart operation only works for uploading directories and the path input
must be identical to the one that generated the restart file

* +-T+ - will renew the socket connection between the client and server
after 10 minutes of connection. This gets around the problem of sockets
getting timed out by the firewall as reported by some users. 

Note that if +-a+ and +-U+ options are used together, it means update all stale
copies and the resource group specified with the +-R+ is ignored. If both the +-a+
and +-R+ are used and the +-R+ specifies a resource group, then a copy is made for
each resource in the resource group. If only the +-a+ option is used and the
object is stored in one of the resources in a resource group, then a copy is
made for each resource in the resource group and any stale copy in the
resource group will also be updated.

Note that if the source copy has a checksum value associated with it, a
checksum will be computed for the replicated copy and compare with the source
value for verification.

Note that replication is always within a zone. For cross-zone duplication see
xref:irsync[+irsync+] which can operate within a zone or across zones.

Options are: 

-----
-a  all - only meaningful if input resource [-R resource] is a resource group.
    Replicate to all the resources in the resource group.
-B  Backup mode - if a good copy already exists in this
    resource, don't make another copy.
-G  resourceGroup  - specifies the source resource group of the data object
    to be replicated. If specified, only copies stored in this resource
    group will be replicated. This option is valid only if the path to be
    replicated is a collection.
-P  output the progress of the replication.
-Q  use RBUDP (datagram) protocol for the data transfer
-U  Update (Synchronize) all old replica with the latest copy.
-M  admin - admin user uses this option to backup/replicate other users files
-N  number  specifies the number of I/O threads to use, by default a rule
    is used to determine the best value.
-r  recursive - copy the whole subtree
-n  replNum  - the replica to copy, typically not needed
-R  destResource - specifies the destination resource to store to.
    This can also be specified in your environment or via a rule set up
    by the administrator.
-S  srcResource - specifies the source resource of the data object to be
    replicated. If specified, only copies stored in this resource will
    be replicated. Otherwise, one of the copy will be replicated.
-T  renew socket connection after 10 minutes
-v  verbose
-V  Very verbose
-X  restartFile - specifies that the restart option is on and the
    restartFile input specifies a local file that contains the restart info.
--purgec  Purge the staged cache copy after replicating an object to a
    COMPOUND resource
--rlock - use advisory read lock for the replication
-h  this help
-----

[[iexit]]
+iexit+
^^^^^^^

Exits iRODS session (cwd) and optionally removes the scrambled password file
produced by +iinit+. 

Usage: +iexit [-vh] [full]+

If +full+ is  included the scrambled password is also removed. 

Options:

-----
-v  verbose
-V  very verbose
-h  this help
-----

[[ipasswd]]
+ipasswd+
^^^^^^^^^

Changes your irods password and, like xref:iinit[+iinit+], stores your new iRODS password in
a scrambled form to be used automatically by the xref:i-commands[i-commands]. Prompts for your
old and new passwords.

Usage: +ipasswd [-hvVl]+

Options:

-----
-v  verbose
-V  Very verbose
-l  long format (somewhat verbose)
-e  echo the password as entered
-f  force: do not ask user to reenter the new password
-h  this help
-----

[[ichksum]]
+ichksum+
^^^^^^^^^

Checksum one or more data-object or collection from iRODS space. 

Usage: +ichksum [-harvV] [-K|f] [-n replNum] [-R resource] [--silent] dataObj|collection ...+

Options:

-----
-f  force - checksum data-objects even if a checksum already exists in iCAT
-a  checksum all replicas. ils -L should be used to list the values of all replicas
-K  verify the checksum value in iCAT. If the checksum value does not exist,
    compute and register one.
-n  replNum  - the replica to checksum; use -a to checksum all replicas.
-R  resource  - the resource of the replica to checksum,
-r  recursive - checksum the whole subtree; the collection, all data-objects
    in the collection, and any subcollections and sub-data-objects in the
    collection.
--silent  - No checksum output except error
-v  verbose
-V  Very verbose
-h  this help
-----

[[imv]]
+imv+
^^^^^

Moves/renames an irods data-object (file) or collection (directory) to another, data-object or collection. The move works if both the source and target are normal (registered in the iCAT) iRODS objects. It also works when the source object is in a mounted collection (object not registered in the iCAT) and the target is a normal object. In fact, this may provide a way to design a drop box where data can be uploaded quickly into a mounted collection and then in the background, moved to the eventual target collection (where data are registered in the iCAT). But currently, the move from a normal collection to a mounted collection is not supported.

If you do a move and rename at the same time, for example, +imv file1 coll1/file2+, it will normally succeed if there's no conflicting data-object name in the source collection (+file2+) but fail (giving error +CAT_NAME_EXISTS_AS_DATAOBJ+) if there is, since, internally IRODS is doing a rename and then a move. Please handle this by running multiple separate +imv+ commands. 

Usage: +imv [-hvV] srcDataObj|srcColl ... destDataObj|destColl+

Options:

-----
-v verbose - display various messages while processing
-V very verbose
-h help - this help 
-----

[[iphymv]]
+iphymv+
^^^^^^^^

Physically move a file in iRODS to another storage resource.

Note that if the source copy has a checksum value associated with it, a
checksum will be computed for the replicated copy and compare with the source
value for verification. 

Usage: +iphymv [-hMrvV] [-n replNum] [-S srcResource] [-R destResource] [-G destRescGrp] dataObj|collection ... +

Options:

-----
-r  recursive - phymove the whole subtree
-M  admin - admin user uses this option to phymove other users files
-n  replNum  - the replica to be phymoved, typically not needed
-S  srcResource - specifies the source resource for the move.
    If specified, only copies stored in this resource will be moved.
    Otherwise, one of the copy will be moved
-R  destResource - specifies the destination resource for the move.
    This can also be specified, in your environment or via a rule
-G  destRescGrp - specifies the destination resource group
    set up by the administrator.
-v  verbose
-V  Very verbose
-h  this help
-----

[[ireg]]
+ireg+
^^^^^^

Register a file or a directory of files and subdirectory into iRODS. The file
or the directory of files must already exist on the server where the resource
is located. The full path must be supplied for both the +physicalFilePath+ and
the +irodsPath+.

With the +-C+ option, the entire content beneath the +physicalFilePath+ (files and
subdirectories) will be recursively registered beneath the +irodsPath+. For
example, the command: 

-----
ireg -C /tmp/src1 /tempZone/home/myUser/src1
-----

grafts all files and subdirectories beneath the directory +/tmp/src1+ to the
collection +/tempZone/home/myUser/src1+.

An admin user will be able to register any Unix directory. But for a regular
user, he/she needs to have a UNIX account on the server with the same name as
his/her iRODS user account and only UNIX directories created with this account
can be registered by the user. Access control to the registered data will be
based on the access permission of the registeed collection.

For security reasons, file permissions are checked to make sure that the
client has the proper permission for the registration. The xref:acNoChkFilePathPerm[+acNoChkFilePathPerm+]
rule in +core.re+ can be used to bypass the path checking. 

Usage: +ireg [-hfCkKvV] [--repl] [-D dataType] [-R resource] [-G rescGroup] physicalFilePath, irodsPath+

Options:

-----
-G  rescGroup - specifies the resource group of the resource. This must be
    input together with the -R option
-R  resource - specifies the resource to store to. This can also be specified
    in your environment or via a rule set up by the administrator.
-C  the specified path is a directory. The default assumes the path is a file.
-f  Force. If the target collection already exists, register the files and
    subdirectories that have not already been registered in the directory.
-k  calculate a checksum on the iRODS client and store with the file details.
-K  calculate a checksum on the iRODS server and store with the file details.
--repl  register the physical path as a replica.
--exclude-from filename - don't register files matching patterns contained
    in the specified file. The file must be readable on the server where the
    resource is located and must be an absolute pathname.
-v  verbose
-V  Very verbose
--hash md5|sha256 - use the specified file hash type (checksum) instead of
    the default.  [The rest of this -h text varies depending on the build, for
example:
    This 'ireg' is built without sha256 support
    so the '--hash' option is not available.
    See https://www.irods.org/index.php/File_Hashes for more. ]
-h  this help
-----

[[irmtrash]]
+irmtrash+
^^^^^^^^^^

Remove one or more data-object or collection from a RODS trash bin. If the
input +dataObj|collection+ is not specified, the entire trash bin of the user
(+/$myZone/trash/$myUserName+) will be removed.

The +dataObj|collection+ can be used to specify the paths of +dataObj|collection+
in the trash bin to be deleted. If the path is relative (does not start with
+/+), the path assumed to be relative to be the user's trash home path e.g.,
+/myZone/trash/home/myUserName+.

An admin user can use the +-M+ option to delete other users' trash bin. The +-u+
option can be used by an admin user to delete the trash bin of a specific
user. If the +-u+ option is not used, the trash bins of all users will be
deleted. 

Usage: +irmtrash [-hMrvV] [--orphan] [-u user] [-z zoneName] [--age age_in_minutes] [dataObj|collection ...]+

Options:

-----
-r  recursive - remove the whole subtree; the collection, all data-objects
    in the collection, and any subcollections and sub-data-objects in the
    collection.
-M  admin mode
--orphan  remove the orphan files in the /myZone/trash/orphan collection
    It must be used with the -M option.
-u  user - Used with the -M option allowing an admin user to delete a
    specific user's trash bin.
-v  verbose
-V  Very verbose
-z  zoneName - the zone where the rm trash will be carried out
--age age_in_minutes - The minimum age of the copy in minutes for removal.
-h  this help
-----

[[irsync]]
+irsync+
^^^^^^^^

Synchronize the data between a local copy (local file system) and the copy
stored in iRODS or between two iRODS copies. The command can be in one of the
three modes  : synchronization of data from the client's local file system to
iRODS, from iRODS to the local file system, or from one iRODS path to another
iRODS path. The mode is determined by the way the +sourceFile|sourceDirectory+
and +targetFile|targetDirectory+ are specified. Files and directories prepended
with +i:+ are iRODS files and collections. Local files and directories are
specified without any prependage. For example, the command: 

-----
irsync -r foo1 i:foo2
-----

synchronizes recursively the data from the local directory +foo1+ to the iRODS
collection +foo2+ and the command: 

-----
 irsync -r i:foo1 foo2
-----

synchronizes recursively the data from the iRODS collection foo1 to the local
directory +foo2+. 

-----
irsync -r i:foo1 i:foo2
-----

synchronizes recursively the data from the iRODS collection foo1 to another
iRODS collection +foo2+. 

The command compares the checksum values and file sizes of the source and
target files to determine whether synchronization is needed. Therefore, the
command will run faster if the checksum value for the specific iRODS file, no
matter whether it is a source or target, already exists and is registered with
iCAT. This can be achieved by using the +-k+ or +-K+ options of the xref:iput[+iput+] command
at the time of ingestion, or by using the xref:ichksum[+ichksum+] command after the data have
already been ingested into iRODS. If the +-s+ option is used, only the file size
(instead of the the size and checksum value) is used for determining whether
synchronization is needed. This mode is gives a faster operation but the
result is less accurate.

The command accepts multiple +sourceFiles|sourceDirectories+ and a single
+targetFile|targetDirectory+. It pretty much follows the syntax of the UNIX +cp+
command with one exception - xref:irsync[+irsync+] of a single source directory to a single
target directory. In UNIX, the command: 

-----
cp -r foo1 foo2
-----

has a different meaning depending on whether the target directory +foo2+ exists.
If the target directory exists,the content of source directory foo1 is copied
to the target directory +foo2/foo1+. But if the target directory does not exist,
the content is copied to the target directory +foo2+. 

With the +irsync+ command, 

-----
irsync -r foo1 i:foo2
-----

always means the synchronization of the local directory foo1 to collection
+foo2+, no matter whether +foo2+ exists or not. 


Usage: +irsync [-rahKsvV] [-N numThreads] [-R resource] [--link] [--age age_in_minutes] sourceFile|sourceDirectory [....] targetFile|targetDirectory+

Options:

-----
-K  verify checksum - calculate and verify the checksum on the data
-N  numThreads - the number of thread to use for the transfer. A value of
      0 means no threading. By default (-N option not used) the server
      decides the number of threads to use.
-R  resource - specifies the target resource. This can also be specified in
your environment or via a rule set up by the administrator.
-r  recursive - store the whole subdirectory
-v  verbose
-V  Very verbose
-h  this help
-l  lists all the source files that needs to be synchronized (including their
filesize in bytes) wrt to the target without actually doing the
synchronization.
--link - ignore symlink. Valid only for rsync from local host to iRODS.
-a   synchronize to all replica if the target is a  iRODS file/collection.
-s   use the size instead of the checksum value for determining
     synchronization.
--age age_in_minutes - The maximum age of the source copy in minutes for sync.
     i.e., age larger than age_in_minutes will not be synced.
--hash md5|sha256 - use the specified file hash type (checksum) instead of
     the default.  [The rest of this text printed via -h will indicate how
         your version was built: for example:
     This 'irsync' is built without sha256 support
     so the '--hash' option is not available.
     See https://www.irods.org/index.php/File_Hashes for more. ]
-----

See also xref:irepl[+irepl+] for the replication and synchronization of
physical copies.

[[iticket]]
+iticket+
^^^^^^^^^

Tickets are another way to provide access to iRODS data-objects (files) or
collections (directories or folders). The +iticket+ command allows you to
create, modify, list, and delete tickets. When you create a ticket its 16
character string it given to you which you can share with others. This is less
secure than normal iRODS login-based access control, but is useful in some
situations. See the 'ticket-based access' page on irods.org for more
information.

A blank execute line invokes the interactive mode, where iticket prompts and
executes commands until +quit+ or +q+ is entered. Like other unix utilities, a
series of commands can be piped into it: +cat file1 | iticket+ (maintaining
one connection for all commands).

Use +help command+ for more help on a specific command. 

Usage: +iticket [-h] [command]+

where:

* +-h+ - Help.

The available +command+ values are:

* +create read/write Object-Name [string]+ - create a new ticket
* +mod Ticket_string-or-id uses/expire string-or-none+ - modify restrictions
* +mod Ticket_string-or-id write-bytes-or-file number-or-0+ - modify restrictions
* +mod Ticket_string-or-id add/remove host/user/group string+ - modify restrictions
* +ls [Ticket_string-or-id]+ - non-admins will see just their own tickets
* +ls-all+ - list all your tickets, even with missing targets
* +delete ticket_string-or-id+
* +quit+

Reference:
https://wiki.irods.org/index.php/iticket[+https://wiki.irods.org/index.php/iticket+]

[[itrim]]
+itrim+
^^^^^^^

Trim down the number of replicas of a file in iRODS by deleting some replicas.
Nothing will be done if the number of current replicas is less than or equal
to +numCopies+. The +-n+ and the +-S+ options are used to specify which copies to
delete. If neither of these options are used, the replicas will be trimmed
until there are +numCopies+ left. Old copies will be trimmed first, then the
'cache' class copies.

*Usage*: +itrim [-hMrvV] [--age age_in_minutes] [--dryrun] [-n replNum]|[-S srcResource] [-N numCopies] dataObj|collection ...+

Options:

-----
-M  admin - admin user uses this option to trim other users' files
-n  replNum  - the replica number of the replica to be deleted
-N  numCopies - minimum number of most current copies to keep. The default
    value is 2.
-r  recursive - trim the whole subtree
-S  srcResource - specifies the resource of the replica to be deleted.
    If specified, only copies stored in this resource will be candidates
    for the deletion.
-v  verbose
-V  Very verbose
--age age_in_minutes - The minimum age of the copy in minutes for trimming.
    i.e., a copy will not be trimmed if its age is less than age_in_minutes.
--dryrun - Do a dry run. No copies will actually be trimmed.
-h  this help
-----

Reference:
https://wiki.irods.org/index.php/itrim[+https://wiki.irods.org/index.php/itrim+]

[[iexecmd]]
+iexecmd+
^^^^^^^^^

Remotely Execute a command installed in the +server/bin/cmd+ directory of the
server. The input parameter +command+ is the remote command to execute. Input
arguments for the command is supported by appending arguments to the command
to be executed. The command and arguments must be in quotes to differentiate
the arguments from the arguments of the +iexecmd+, e.g.: 

-----
iexecmd -H zero.sdsc.edu "hello Mary"
-----

If neither +-H+, +-p+ nor +-P+ is specified, the command will be executed on the
host where the client is connected.

*Usage*: +iexecmd [-hv] [-p hintPath]|[-P hintPath] [-H hostAddr] command+

Options:

-----
-H  hostAddr - the host address where the command will be executed.
-p  hintPath - A full iRODS file path. The command will be executed on
     the host where this file is stored.
-P  hintPath - Same as the -p option except that the resolved pphysical
     path from the logical hintPath will be used as the first argument
     the command
-v  verbose
-h  this help
-----

Reference:
https://wiki.irods.org/index.php/iexecmd[+https://wiki.irods.org/index.php/iexecmd+]

[[imcoll]]
+imcoll+
^^^^^^^^

Used to manage (mount, unmount, link, synchronize and purge of cache) iRODS
collections and the associated cache. Full path must be supplied for both
+physicalFilePath+ and +irodsPath+.

The +-m+ option can be used to associate (mount) an iRODS collection with a a
physical directory (e.g.,a UNIX directory) or a structured file. If the
+mountType+ is +f+ or +filesystem+, the first argument is the UNIX directory
path to be mounted. Only the top level collection/directory will be
registered. The entire content of the registered directory can then be
accessed using iRODS commands such as
xref:iput[+iput+], xref:iget[+iget+], xref:ils[+ils+] and the client APIs.
This is simlilar to mounting a UNIX file system except that a UNIX directory
is mounted to an iRODS collection. For example, the following command mounts
the +/temp/myDir+ UNIX directory to the 
+/tempZone/home/myUser/mymount+ collection:

-----
imcoll -m filesystem /temp/myDir /tempZone/home/myUser/mymount
-----

An admin user will be able to mount any Unix directory. But for normal user,
he/she needs to have a UNIX account on the server with the same name as
his/her iRODS user account and only UNIX directory created with this account
can be mounted by the user. Access control to the mounted data will be based
on the access permission of the mounted collection.

If the +mountType+ is +l+ or +link+, the request is for a collection soft link.
The first argument is the iRODS collection to be linked or the target
collection name. The second argument is the link collection name. The link
collection must not exist or must be an empty collection. If the +mountType+ is
+t+ or +tar+, the first argument is the iRODS logical path of a tar file which
will be used as the 'strucuted file' for the mounted collection. The +-R+
resource option is used to specify the resource to create this tar structured
file in case it does not already exist. Once the tar structured file is
mounted, the content of the tar file can be accessed using iRODS commands such
as xref:iput[+iput+], xref:iget[+iget+], xref:ils[+ils+] and the client APIs. For example, the following command
mounts the iRODS tar file +/tZone/home/myUser/tar/foo.tar+ to the
+/tZone/home/myUser/tarcoll+ collection: 

-----
 imcoll -m tar /tZone/home/myUser/tar/foo.tar /tZone/home/myUser/tardir
-----

The tar structured file implementation uses a cache on the server to cache the
mounted tar file. i.e., the tar file is untarred to a cache on the server
before any iRODS operation. The xref:ils[+ils+] +-L+ command can be use to list the
properties of a mounted collection and the status of the associated cache. For
example, the following is the output of the xref:ils[+ils+] command:

-----
C- /tZone/home/myUser/tardir  tarStructFile  /tZone/home/myUser/tar/foo.tar  /data/Vault8/rods/tar/foo.tar.cacheDir0;;;demoResc;;;1
-----

The output shows that +/tZone/home/myUser/tardir+ is a tar structured file
mounted collection. The iRODS path of the tar file is in
+/tZone/home/myUser/tar/foo.tar+. The last item actually contains 3 items
separated the string +;;;+. It showed that the tar file is untarred into the
+/data/Vault8/rods/tar/foo.tar.cacheDir0+ directory in the +demoResc+ resource.
The value of +1+' for the last item showed that the cache content has been
changed (dirty) and the original tar file needs be synchronized with the
changes. The +-s+ option can be used to synchronize the tar file with the cache.
For example: 

-----
imcoll -s /tZone/home/myUser/tardir 
-----

The +-p+ option can be used to purge the cache.

For example: 

-----
imcoll -p /tZone/home/myUser/tardir
-----

The +-s+ and +-p+ can be used together to synchronize the tar file and then purge
the cache.

Note: To use the tar data type for bundling, the server must be linked with
the libtar library. The link: 

-----
 https://www.irods.org/index.php/Mounted_iRODS_Collection
-----

under the heading 'Building libtar and linking the iRODS servers with libtar'
gives the instructions for installing libtar. Also note that the current
version of libtar 1.2.11 does not support tar file size larger than 2 GBytes.
We have made a mod to libtar 1.2.11 so that it can handle files larger than 2
GBytes. This mod is only needed for building the irods server software. Please
contact all@diceresearch.org for this mod.

If the +mountType+ is +h+ or +haaw+, the first argument is the logical path of a
haaw type structured file developed by UK eScience.

Note: the haaw type structured file has NOT yet been implemented.

If the +mountType+ is +m+ or +msso+, the first argument is the logical path of a
workflow file of type +msso+. The second argument is the collection where
results of the workflow execution will be stored.

The +-U+ option can be used to unmount an iRODS collection. For example, the
following command unmounts the +/tempZone/home/myUser/mymount+ collection: 

-----
 imcoll -U /tempZone/home/myUser/mymount
-----

*Usage*: +imcoll -m mountType [-R resource] mountDirectory|structuredFilePath irodsCollection+

*Usage*: +imcoll -Usp irodsCollection+

*Options*:

-----
-R  resource - specifies the resource to store to. This can also be specified
    in your environment or via a rule set up by the administrator.
-m  mountType - mount a directory or structured file to a collection
      Valid mountType are f|filesystem, l|link, t|tar, h|haaw and m|msso
-U  unmount the collection
-s  synchronize the tar file with the cache
-p  purge the associated cache
-h  this help
-----

Reference:
https://wiki.irods.org/index.php/imcoll[+https://wiki.irods.org/index.php/imcoll+]

[[ibun]]
+ibun+
^^^^^^

*Summary*: A command for bundle file operations. This command allows structured files such as tar files to be uploaded and downloaded to/from iRODS.

A tar file containing many small files can be created with normal unix tar command on the client and then uploaded to the iRODS server as a normal iRODS file. The +ibun -x+ command can then be used to extract/untar the uploaded tar file. The extracted subfiles and subdirectories will appeared as normal iRODS files and sub-collections. The +ibun -c+ command can be used to tar/bundle an iRODS collection into a tar file.

For example, to upload a directory +mydir+ to iRODS: 

-----
   tar -chlf mydir.tar -C /x/y/z/mydir .
   iput -Dtar mydir.tar .
   ibun -x mydir.tar mydir
-----

Note the use of +-C+ option with the tar command which will tar the content of +mydir+ but without including the directory +mydir+ in the paths. The +ibun -x+ command extracts the tar file into the +mydir+ collection. The target +mydir+ collection does not have to exist nor be empty. If a subfile already exists in the target collection, the ingestion of this subfile will fail (unless the +-f+ flag is set) but the process will continue.

It is generally a good practice to tag the tar file using the +-Dtar+ flag when uploading the file using
xref:iput[+iput+]. But if the tag is not made, the server assumes it is a tar +dataType+. The +dataType+ tag can be added afterward with the xref:isysmeta[+isysmeta+] command. For example:

-----
isysmeta mod /tempZone/home/rods/mydir.tar datatype 'tar file'
-----

The following command bundles the iRods collection +mydir+ into a tar file:

-----
 ibun -cDtar mydir1.tar mydir
-----

If a copy of a file to be bundled does not exist on the target resource, a replica will automatically be made on the target resource. Again, if the +-D+ flag is not use, the bundling will be done using tar.

The +-b+ option when used with the +-x+ option, specifies bulk registration which does up to 50 rgistrations at a time to reduce overhead. 

*Usage*: +ibun -x [-hb] [-R resource] structFilePath irodsCollection+

*Usage*: +ibun -c [-hf] [-R resource] [-D dataType] structFilePath irodsCollection+

*Usage*: +ibun --add [-h] structFilePath irodsCollection+


*Options*:

-----
-b  bulk registration when used with -x to reduce overhead
-R  resource - specifies the resource to store to. This is optional
    in your environment
-D  dataType - the struct file data type. Valid only for -c option for
    specifying the target data type. Valid dataTypes are - t|tar|'tar file'
    for tar file. g|gzip|gzipTar for gziped tar file, b|bzip2|bzip2Tar for
    bzip2 file, and z|zip|zipFile for archive using 'zip'.  If -D is not
    specified, the default is a tar file type
-x  extract the structFile and register the extracted files and directories
    under the input irodsCollection
-c  bundle the files and sub-collection underneath the input irodsCollection
    and store it in the structFilePath
-f  force overwrite the struct file (-c) or the subfiles (-x).
--add  add or append to existing tar file. The tar file must not be compressed
-h  this help
-----

*Reference*:
https://wiki.irods.org/index.php/ibun[+https://wiki.irods.org/index.php/ibun+]

[[iphybun]]
+iphybun+
^^^^^^^^^

*Summary*: Allows system admin to physically bundle files in a collection into
a number of tar files to make it more efficient to store these files on tape.
The tar files are placed into the +/myZone/bundle/....+ collection with file
names - +collection.aRandomNumber+. A new tar file will be created whenever the
number of subfiles exceeds 5120 (default value or the value given by the +-N+
option) or the total size of the subfiles exceeds 4 GBytes (default value or
the value given by the +-s+ option). A replica is registered for each bundled
sub-files with a fictitious resource - +bundleResc+ and a physical file path
pointing to the logical path of the tar bundle file. Whenever this copy of the
subfile is accessed, the tar file is untarred and staged automatically to the
'cache' resource. Each extracted file is registered as a replica of its
corresponding subfiles.

A tar bundle file can be replicated or trimmed independently from its
corresponding subfiles. But it cannot be renamed or moved to trash. It can be
removed with the xref:irm[+irm+] +-f+ command. But this will trigger the staging of the
subfiles before the tar file is removed. The +-R+ flag specifies the resource of
the bundle tar file. This input is mandatory. The input resource must be a
+cache+ type resource or a resource group that contains at least one +cache+
type resource.

*Usage*: +iphybun [-hK] [-D dataType] [-S srcResource] [-R resource] [-s maxSize_in_GB] [-N numOfSubFiles] collection ...+

*Options*: 

-----
-D  dataType - the target struct file dataType. Valid dataTypes are -
    t|tar|'tar file' for tar file, g|gzip|gzipTar for gziped tar file,
    b|bzip2|bzip2Tar for bzip2 file, and z|zip|zipFile for archive using
    'zip'.  If -D is not specified, the default is a tar file type
-N  numOfSubFiles - maximum number of subfiles that are contained in the
    tar file. If this option is not given, the default value will be 5120.
    Note that if this number is too high, it can cause some significant
    overhead for operations like retrieving a single file within a tar file
    (stage, untar and register in iRODS lots of files).
-R  resource - The resource where the bundle file is located
-S  srcResource - Only files in this resource will be bundled
-K  compute and register checksum value for the bundled subfiles and the
    bundle file.
-s  maxSize_in_GB - maximum size for the tar bundle file. This is given 
    in GB. If the option is not given, the default value will be 4 GBs.
-h  this help
-----

*Reference*:
https://wiki.irods.org/index.php/iphybun[+https://wiki.irods.org/index.php/iphybun+]

[[igetwild.sh]]
+igetwild.sh+
^^^^^^^^^^^^^

*Summary*: Get one or more iRODS files using wildcard characters. Will prompt
for missing items.
+igetwild.sh+ is a simple script that does some wildcard processing to xref:iget[+iget+]
irods files with names with entered patterns in the names (at the beginning,
end or middle).  For example:

-----
igetwild.sh /newZone/home/rods .txt
-----

will get each iRODS file in the collection that ends with +.txt+, e.g.

-----
 foo.txt                         0.000 MB | 0.164 sec | 0 thr |  0.000 MB/s
 foo2.txt                        0.000 MB | 0.101 sec | 0 thr |  0.000 MB/s
-----

Include the collection name, the pattern of the +dataObject+ names and +b+, +e+,or +m+
on the command line, to avoid prompts for them. 

*Usage*: +igetwild.sh collection pattern b|m|e+ (beginning, middle, or end)

*Reference*:
https://wiki.irods.org/index.php/igetwild.sh[+https://wiki.irods.org/index.php/igetwild.sh+]

[[cl-metadata]]
Metadata Commands
~~~~~~~~~~~~~~~~~

[[imeta]]
+imeta+
^^^^^^^

*Summary*:  

Metadata attribute-value-units triplets (AVUs) consist of an Attribute-Name,
Attribute-Value, and an optional Attribute-Units. They can be added via the
+add+ command (and in other ways), and then queried to find matching objects.

The available +command+ values are:

* +add -d|C|R|G|u Name AttName AttValue [AttUnits]+ - Add new AVU triplet
* +addw -d Name AttName AttValue [AttUnits]+ - Add new AVU triplet using Wildcards in +Name+
* +rm  -d|C|R|G|u Name AttName AttValue [AttUnits]+ - Remove AVU
* +rmw -d|C|R|G|u Name AttName AttValue [AttUnits]+ - Remove AVU, use Wildcards
* +mod -d|C|R|G|u Name AttName AttValue [AttUnits] [n:Name] [v:Value] [u:Units]+ - modify AVU; new name (+n:+), value (+v:+), and/or units (+u:+)
* +set -d|C|R|G|u Name AttName newValue [newUnits]+ - Assign a single value
* +ls  -[l]d|C|R|G|u Name [AttName]+ - List existing AVUs for item +Name+
* +lsw -[l]d|C|R|G|u Name [AttName]+ - List existing AVUs, use Wildcards
* +qu -d|C|R|G|u AttName Op AttVal [...]+ - Query objects with matching AVUs
* +cp -d|C|R|G|u -d|C|R|G|u Name1 Name2+ - Copy AVUs from item +Name1+ to +Name2+
* +upper+ - Toggle between upper case mode for queries (qu)

For each command, +-d+, +-C+, +-R+, +-G+ or +-u+ is used to specify which type of object
to work with: dataobjs (irods files), collections, resources, resource groups
or users. (Within +imeta+ +-c+, +-r+ and +-g+ can be used, but +-C+, +-R+ and +-G+ are the
iRODS standard options for collections, resources and resource groups.)

Fields represented with upper case, such as +Name+, are entered values. For
example, +Name+ is the name of a dataobject, collection, resource, or user.

For +rmw+ and +lsw+, the +%+ and +_+ wildcard characters (as defined for SQL) can be
used for matching attribute values.

For +addw+, the +%+ and +_+ wildcard characters (as defined for SQL) can be used for
matching object names. This is currently implemented only for data-objects
(+-d+).

A blank execute line invokes the interactive mode, where +imeta+ prompts and
executes commands until +quit+ or +q+ is entered. Like other unix utilities, a
series of commands can be piped into it: +cat file1 | imeta+ (maintaining one
connection for all commands).

Single or double quotes can be used to enter items with blanks.

Entered usernames are of the form +username[#zone]+. If +#zone+ is not provided,
the zone from your +.irodsEnv+ is assumed.

The appropriate zone (local or remote) is determined from the path names or
via +-z Zonename+ (for +qu+ and when working with resources).

Try +help command+ for more help on a specific command. +help qu+ will explain
additional options on the query. 

*Options*:

-----
-v verbose
-V Very verbose
-z Zonename  work with the specified Zone
-h This help
-----

*Reference*:
https://wiki.irods.org/index.php/imeta[+https://wiki.irods.org/index.php/imeta+]

[[isysmeta]]
+isysmeta+
^^^^^^^^^^

*Summary*:  Show or modify system metadata.

The available +command+ values are:

* +mod DataObjectName Time+ - modify expire time
* +mod DataObjectName datatype Type+ - modify data-type
* +mod DataObjectName comment [replNum] Comment+ - modify the +comment+ of the replica +replNum+ or +0+ by default
* +ls [-lvV] Name+ - list +dataObject+, +-l -v+ for long form
* +ldt+ - list available data types

Examples are:

* +isysmeta mod foo ++1h+ - set the expire time for file +foo+ to an hour from now
* +isysmeta mod /tempZone/home/rods/foo 2009-12-01+
* +isysmeta mod /tempZone/home/rods/foo datatype 'tar file'+
* +isysmeta mod /tempZone/home/rods/dbo1 datatype 'database object'+
* +isysmeta mod /tempZone/home/rods/foo comment 1 'my comment'+
* +isysmeta ls foo+
* +isysmeta -l ls foo+
* +isysmeta ls -l foo+
* +isysmeta ldt+

*Reference*:
https://wiki.irods.org/index.php/isysmeta[+https://wiki.irods.org/index.php/isysmeta+]

[[iquest]]
+iquest+
^^^^^^^^

*Summary*:

*Usage*: +iquest [-hz] [--no-page] [ [hint] format] selectConditionString+

*Usage*: +iquest --sql 'pre-defined SQL string' [format] [arguments]+  

*Usage*: +iquest attrs+

where:

* +format+ is C format restricted to character strings;
* +selectConditionString+ is of the form: +SELECT <attribute> [, <attribute>]*
[WHERE <condition> [ AND <condition>]*]+;
* +attribute+ is found using the
+iquest attrs+ command; 
* +condition+ is of the form +<attribute> <rel-op>
<value>+; 
( +rel-op+ is a relational operator, e.g. +=+, +<>+, +>+, +<+, +like+, +not like+,
+between+, etc.; and
* +value+ is either a constant or a wild-card expression.

Queries in numeric mode are possible by replacing the +<+ operator for instance with
+n<+. It will cast the attribute to numeric (decimal) in the SQL. One can also
use a few aggregation operators such as +sum+, +count+, +min+, +max+ and +avg+, or +order+
and +order_desc+ (descending) to specify an order (if needed).

Use +%+ and +_+ as wild-cards, and use +\+ to escape them.

If +no-distinct+ appears before the +selectConditionString+, the normal
distinct option on the SQL will bypassed (this is useful in rare cases).

If uppercase (or upper) appears before the +selectConditionString+, the database
value in the +where+ condition will be made upper case so one can do
case-insensitive tests (using upper-case literals).

The +--sql+ option executes a pre-defined SQL query. The specified query must
match one defined by the admin (see xref:iadmin[+iadmin+] +h asq+' (add specific query)). A
few of these may be defined at your site. A special alias +ls+ (+--sql ls+) is
normally defined to display these. You can specify these via the full SQL or
the alias, if defined. Generally, it is better to use the general-query (non
+--sql+ forms herein) since that generates the proper SQL (knows how to link the
ICAT tables) and handles access control and other aspects of security. If the
SQL includes arguments, you enter them following the SQL. As without +--sql+,
you can enter a printf format statement to use in formatting the results
(except when using aliases). 

*Examples*:

-----
iquest "SELECT DATA_NAME, DATA_CHECKSUM WHERE DATA_RESC_NAME like 'demo%'"
iquest "For %-12.12s size is %s" "SELECT DATA_NAME ,  DATA_SIZE  WHERE COLL_NAME = '/tempZone/home/rods'"
iquest "SELECT COLL_NAME WHERE COLL_NAME like '/tempZone/home/%'"
iquest "User %-6.6s has %-5.5s access to file %s" "SELECT USER_NAME,  DATA_ACCESS_NAME, DATA_NAME WHERE COLL_NAME = '/tempZone/home/rods'"
iquest " %-5.5s access has been given to user %-6.6s for the file %s" "SELECT DATA_ACCESS_NAME, USER_NAME, DATA_NAME WHERE COLL_NAME = '/tempZone/home/rods'"
iquest no-distinct "select META_DATA_ATTR_NAME"
iquest uppercase "select COLL_NAME, DATA_NAME WHERE DATA_NAME like 'F1'"
iquest "SELECT RESC_NAME, RESC_LOC, RESC_VAULT_PATH, DATA_PATH WHERE DATA_NAME = 't2' AND COLL_NAME = '/tempZone/home/rods'"
iquest "User %-9.9s uses %14.14s bytes in %8.8s files in '%s'" "SELECT USER_NAME, sum(DATA_SIZE),count(DATA_NAME),RESC_NAME"
iquest "select sum(DATA_SIZE) where COLL_NAME = '/tempZone/home/rods'"
iquest "select sum(DATA_SIZE) where COLL_NAME like '/tempZone/home/rods%'"
iquest "select sum(DATA_SIZE), RESC_NAME where COLL_NAME like '/tempZone/home/rods%'"
iquest "select order_desc(DATA_ID) where COLL_NAME like '/tempZone/home/rods%'"
iquest "select count(DATA_ID) where COLL_NAME like '/tempZone/home/rods%'"
iquest "select RESC_NAME where RESC_CLASS_NAME IN ('bundle','archive')"
iquest "select DATA_NAME,DATA_SIZE where DATA_SIZE BETWEEN '100000' '100200'"
-----

*Options*:

-----
-h  this help
-z Zonename  the zone to query (default or invalid uses the local zone)
--no-page    do not prompt asking whether to continue or not
             (by default, prompt after a large number of results (500)
-----

*Reference*:
https://wiki.irods.org/index.php/iquest[+https://wiki.irods.org/index.php/iquest+]

[[idbo]]
+idbo+
^^^^^^

*Summary*: Execute a Database Object (DBO) on a Database Resource (DBR) or
perform other DBO operations. Typical usage: 

-----
idbo exec DBR DBO
-----

A single command can be entered on the command line or, if blank, it will
prompt go into interactive mode and prompt for commands.
The available +command+ values are:

* +open DBR+ - open a database resource
* +close DBR+ - close a database resource
* +exec DBR DBO [arguments]+ - execute a DBO on a DBR
* +output [-f] DBOR+ - store 'exec' results in another data-object
* +commit DBR+ - commit updates to a DBR (done via a DBO)
* +rollback DBR+ - rollback updates instead
* +ls+ - list defined Database-Objects in the Zone
* +help+ or +h+ [command]+ - this help, or help on a command
* +quit+ or +q+ - exit idbo

where
+DBR+ and +DBO+ are the names of a Database Resource and Database Object.
You can exectute a DBO without first opening the DBR (in which case the server
will open and close it), so you can run a DBO from the command line: +idbo
exec DBR DBO+.

Like other unix utilities, a series of commands can be piped into it: +cat
file1 | idbo+ (maintaining one connection for all commands).

See 'Database Resources' on the irods web site for more information.

Try +help command+ for more help on a specific command. +help exec+ will
explain options on the exec command. 


*Reference*:
https://wiki.irods.org/index.php/idbo[+https://wiki.irods.org/index.php/idbo+]

[[cl-info]]
Informational Commands
~~~~~~~~~~~~~~~~~~~~~~

[[ienv]]
*ienv*
^^^^^^

*Summary*: Displays current iRODS environment.  This is equivalent to
the i-command xref:iinit[+iinit+] +l+.

*Usage*: +ienv [-h]+

*Options*:

-----
-h  this help
-----

*Reference*:
https://wiki.irods.org/index.php/ienv[+https://wiki.irods.org/index.php/ienv+]

[[ilsresc]]
+ilsresc+
^^^^^^^^^

*Summary*: Lists iRODS resources and resource-groups.

If +Name+ is present, list only that resource or resource-group, otherwise
list them all.

*Usage*: + ilsresc [-lvVhA] [Name]+

*Options*:

-----
-l Long format - list details
-v verbose
-V Very verbose
-z Zonename  list resources of specified Zone
-A Rescname  list the access permissions (applies to Database Resources only)
-h This help
-----

*Reference*:
https://wiki.irods.org/index.php/ilsresc[+https://wiki.irods.org/index.php/ilsresc+]

[[iuserinfo]]
+iuserinfo+
^^^^^^^^^^^

*Summary*: Shows information about your iRODS user account or the entered user.

*Usage*: +iuserinfo [-vVh] [user]+

*Options*:

-----
-v  verbose
-V  very verbose
-h  this help
-----

[[imiscsvrinfo]]
+imiscsvrinfo+
^^^^^^^^^^^^^^

*Summary*: Connect to the server and retrieve some basic server information.
Can be used as a simple test for connecting to the server. 

*Usage*: +imiscsrvinfo [-hvV]+

*Options*:

-----
-v  verbose
-V  Very verbose
-h  this help
-----


*Reference*:
https://wiki.irods.org/index.php/imiscsvrinfo[+https://wiki.irods.org/index.php/imiscsvrinfo+]

[[ihelp]]
+ihelp+
^^^^^^^

*Summary*: Display i-commands synopsis or a particular i-command help text. Run with no options to display a synopsis of the i-commands.

*Usage*: +ihelp [-ah] [icommand]+

*Options*:

-----
-h  this help
-a  print the help text for all the i-commands
-----

*Reference*:
https://wiki.irods.org/index.php/ihelp[+https://wiki.irods.org/index.php/ihelp+]

[[ixmsg]]
+ixmsg+
^^^^^^^

*Summary*:

*Usage*: +ixmsg s [-t ticketNum] [-n startingMessageNumber] [-r numOfReceivers] [-H header] [-M message]+

*Usage*: +ixmsg r [-n NumberOfMessages] [-t tickefStreamtNum] [-s startingSequenceNumber] [-c conditionString]+

*Usage*: +ixmsg t+

*Usage*: +ixmsg d -t ticketNum+

*Usage*: +ixmsg c -t ticketNum+

*Usage*: +ixmsg c -t ticketNum -s sequenceNum+

*Options*:

-----
   s: send messages. If no ticketNum is given, 1 is used 
   r: receive messages. If no ticketNum is given, 1 is used 
   t: create new message stream and get a new ticketNum 
   d: drop message Stream 
   c: clear message Stream 
   e: erase a message 
-----

*Reference*:  https://wiki.irods.org/index.php/ixmsg[+https://wiki.irods.org/index.php/ixmsg+]


[[ips]]
+ips+
^^^^^

*Summary*: Display connection information of iRODS agents currently running in the iRODS federation. By default, agent info for the iCAT enabled server (IES) is displayed.

The +-H+ and +-R+ option can be used to specify other servers for the info display. The +-z+ option can be used to specify a remote zone for the info display. If the +-a+ option is used, agent info for all servers in the iRODS federation will be displayed.

By default, a line is output for each connection. Each line contains items given in the following order: 

* pid of the agent process
* client user
* wall clock time of the connection
* the client process
* the +from+ address of the connection

If the +-v+ option is specified, the proxy user of the connection is added following the client user.

*Usage*:  +ips [-ahv] [-R resource] [-z zone] [-H hostAddr]+

*Options*:

-----
-a  all servers
-h  this help
-H  hostAddr - the host address of the server
-R  resource - the server where the resource is located
-v  verbose
-z  zone - the remote zone
-----

*Reference*:
https://wiki.irods.org/index.php/ips[+https://wiki.irods.org/index.php/ips+]

[[ilocate]]
+ilocate+
^^^^^^^^^

*Summary*:  Search through your current iRODS zone for data-object(s) OR
collections (i.e. filenames and directories) which match the provided search
pattern. Use +%+ as a wildcard (emulates sql +like+ operand). If you need to
use +\%+ to express +%+ as a literal, you must encapsulate the search pattern
with quotes. 

*Usage*:  +ilocate [options] searchPattern [searchPattern] [searchPattern]...+

*Options*:

-----
-0  Separate output via NULL characters instead of newlines (like find -print0)
-t  Also show objects in trash
-----

Note: +ilocate+ is a script. For version information, check +ilocate+'s path and
make sure the correct version of the i-commands is in the +PATH+. 

*Reference*:
https://wiki.irods.org/index.php/ilocate[+https://wiki.irods.org/index.php/ilocate+]


[[ierror]]
+ierror+
^^^^^^^^

*Summary*: Converts an irods error code to text. 

*Usage*: +ierror [-vVh] errorNumber+

The +errorNumber+ can be preceded with a minus sign or not.
An example is:

-----
$ ierror -826000
 irods error: -826000 CAT_INVALID_AUTHENTICATION

The CAT_ series indicates that this error was returned by a Catalog (ICAT)
function and INVALID_AUTHENTICATION means
that, most likely, the entered password was incorrect.
-----

*Options*: 

-----
-h  this help
-----

*Reference*:
https://wiki.irods.org/index.php/ierror[+https://wiki.irods.org/index.php/ierror+]

[[iquota]]
+iquota+
^^^^^^^^

*Summary*: Show information on iRODS quotas (if any). By default, information
is displayed for the current iRODS user. 

*Usage*: +iquota [-uavVh] [UserName] [usage]+

The +over+ values indicate whether the user or group is over quota or not and
by how much; positive values are over-quota. The +usage+ information shows how
much data is stored on each resource, when last determined.

*Options*: 

-----
-a All users 
-u UserName[#ZoneName] - show usage information for the specified user
-----

*Examples*: 

-----
iquota
iquota -a
iquota usage
iqouta -a usage
iquota -u josh
-----

*Reference*:
https://wiki.irods.org/index.php/iquota[+https://wiki.irods.org/index.php/iquota+]

[[cl-admin]]
Administration Commands
~~~~~~~~~~~~~~~~~~~~~~~

[[iadmin]]
+iadmin+
^^^^^^^^

*Summary*:  Various commands to gather information.

*Usage*: +iadmin [-hvV] [command]+

where the available +command+ values are:

-----
lu [name[#Zone]] (list user info; details if name entered)
lua [name[#Zone]] (list user authentication (GSI/Kerberos Names, if any))
luan Name (list users associated with auth name (GSI/Kerberos)
lt [name] [subname] (list token info)
lr [name] (list resource info)
ls [name] (list directory: subdirs and files)
lz [name] (list zone info)
lg [name] (list group info (user member list))
lgd name (list group details)
lrg [name] (list resource group info)
lf DataId (list file details; DataId is the number (from ls))
mkuser Name[#Zone] Type (make user)
moduser Name[#Zone] [ type | zone | comment | info | password ] newValue
aua Name[#Zone] Auth-Name (add user authentication-name (GSI/Kerberos)
rua Name[#Zone] Auth-Name (remove user authentication name (GSI/Kerberos)
rpp Name (remove PAM-derived Password for user Name)
rmuser Name[#Zone] (remove user, where userName: name[@department][#zone])
mkdir Name [username] (make directory(collection))
rmdir Name (remove directory)
mkresc Name Type Class Host [Path] (make Resource)
modresc Name [name, type, class, host, path, status, comment, info, freespace]
Value (mod Resc)
modresc Name host-add|host-rm host (for WOS resources)
modrescdatapaths Name oldpath newpath [user] (update data-object paths,
sometimes needed after modresc path)
rmresc Name (remove resource)
mkzone Name Type(remote) [Connection-info] [Comment] (make zone)
modzone Name [ name | conn | comment ] newValue (modify zone)
modzonecollacl null|read userOrGroup /remotezone (set strict-mode root ACLs
rmzone Name (remove zone)
mkgroup Name (make group)
rmgroup Name (remove group)
atg groupName userName[#Zone] (add to group - add a user to a group)
rfg groupName userName[#Zone] (remove from group - remove a user from a group)
atrg resourceGroupName resourceName (add (resource) to resource group)
rfrg resourceGroupName resourceName (remove (resource) from resource group)
at tokenNamespace Name [Value1] [Value2] [Value3] (add token)
rt tokenNamespace Name [Value1] (remove token)
spass Password Key (print a scrambled form of a password for DB)
dspass Password Key (descramble a password and print it)
pv [date-time] [repeat-time(minutes)] (initiate a periodic rule to vacuum the
DB)
ctime Time (convert an iRODS time (integer) to local time; & other forms)
suq User ResourceName-or-'total' Value (set user quota)
sgq Group ResourceName-or-'total' Value (set group quota)
lq [Name] List Quotas
cu (calulate usage (for quotas))
rum (remove unused metadata (user-defined AVUs)
asq 'SQL query' [Alias] (add specific query)
rsq 'SQL query' or Alias (remove specific query)
help (or h) [command] (this is help, or more details about a command)
-----

See also xref:irmtrash[+irmtrash+] +-M -u user+ for the admin mode of removing
trash and similar admin modes in xref:irepl[+irepl+], xref:iphymv[+iphymv+], xref:itrim[+itrim+], and 
xref:ichmod[+ichmod+].
The admin can also alias as any user via the +clientUserName+ environment
variable.

*Reference*:
https://wiki.irods.org/index.php/iadmin[+https://wiki.irods.org/index.php/iadmin+]

[[ifsck]]
+ifsck+
^^^^^^^

*Summary*: Check if a local data object or a local collection content is
consistent in size (or optionally its checksum) with its registered size (and
optionally its checksum) in iRODS. It allows to detect iRODS files which have
been corrupted or modified outside the iRODS framework on the local filesytem.
+srcPhysicalFile+ or +srcPhysicalDirectory+ must be a full path name.

*Usage*: +ifsck [-rhK] srcPhysicalFile|srcPhysicalDirectory ...+

*Options*:

-----
-K  verify the checksum of the local file wrt the one registered in iRODS.
    Only relevant if the checksum has been computed for the iRODS objects.
-r  recursive - scan local subdirectories
-h  this help
-----

*Reference*:
https://wiki.irods.org/index.php/ifsck[+https://wiki.irods.org/index.php/ifsck+] 

[[iscan]]
+iscan+
^^^^^^^

*Summary*: If the input is a local data file or a local directory, it checks
if the content is registered in irods. It allows to detect orphan files,
+srcPhysicalFile+ or +srcPhysicalDirectory+ must be a full path name. If the input
is an iRODS file or an iRODS collection, it checks if the physical files
corresponding to the iRODS object does exist on the data servers. For
+srcDataObj+ and +srcCollection+ (iRODS objects), it must be prepended with +i:+.

*Usage*: +iscan [-rh] srcPhysicalFile|srcPhysicalDirectory|srcDataObj|srcCollection+

*Options*: 

-----
-r  recursive - scan local subdirectories or subcollections
-h  this help
-----

*Reference*:  https://wiki.irods.org/index.php/iscan[+https://wiki.irods.org/index.php/iscan+]

[[igroupadmin]]
+igroupadmin+
^^^^^^^^^^^^^

*Summary*: This is for users of type 'groupadmin' which are allowed to perform certain administrative functions. It can also be used by regular users to list groups ('lg') and by the admin for all operations.

A blank execute line invokes the interactive mode, where it prompts and executes commands until 'quit' or 'q' is entered. Single or double quotes can be used to enter items with blanks.

*Usage*: +igroupadmin [-hvV] [command]+

The available values for +command+ are:

-----
lg [name] (list group info (user member list))
mkuser Name Password (make a user and set the initial password)
atg groupName userName[#Zone] (add to group - add a user to a group)
rfg groupName userName[#Zone] (remove from group - remove a user from a group)
mkgroup groupName[#Zone] (make a new group)
help (or h) [command] (this help, or more details on a command)
-----

*Reference*:  https://wiki.irods.org/index.php/igroupadmin[+https://wiki.irods.org/index.php/igroupadmin+]

[[cl-rules]]
Rules and Delayed Rule Execution Commands
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[irule]]
+irule+
^^^^^^^

*Summary*:  Submit a user defined rule to be executed by an iRODS server.

*Usage*: +irule [--test] [-v] rule inputParam outParamDesc+

*Usage*: +irule [--test] [-v] [-l] -F inputFile [prompt | arg_1 arg_2 ...]+

The first usage form requires three inputs:

* +rule+ - the rule to be executed;
* +inputParam+ - The input parameters. The input values for the rule is
      specified here. If there is no input, a string containing "null"
      must be specified.
* +outParamDesc+ - Description for the set of output parameters to be 
      returned. If there is no output, a string containing "null"
      must be specified.

The second usage form reads the rule and arguments from the file +inputFile+.
Arguments following +inputFile+ in this form are interpreted as input
arguments for the rule.  These arguments are interpreted in two ways:

* The arguments require the +label=value+ format, where only named pairs are
replaced.  Any remaining arguments get their values from the +inputFile+, and
all labels start with +*+.

* The arguments are specified as inputs without any labels, with the keyword
+default+ used to specify using the +inputFile+ value, and +\+ used as the
first letter in an argument as an escape.

The +inputFile+ should contain three lines of non-comments:

* a first line that specifies the rule;

* a second line specifying the input arguments as +label=value+ pairs
separated by +%+,

** with +%%+ used if +%+ is needed as an input value;

** input values can begin with +$+, in which case the user will be prompted.  A default
value can also be listed after the +$+, e.g. +*A=$40+.  If prompted, the
default value will be used if the user presses return without giving a
replacement.

** the input line can also be just the word +null+

* a third line containing output parameters as labels separated by +%+,
and this line can also be just the word +null+.

The parameter +arg_1+ is of the form +*arg=value+.  For example, using
+*A=$+ as one of the arguments in line two of the +inputFile+, +irule+ will
prompt for +*A+ or the user can enter it on the command line, e.g.

-----
  irule -F filename *A=23
    (integer parameters can be unquoted)
   or
   irule -F filename "*A='/path/of/interest'" *B=24
   irule -F filename "*A=\"/path/of/interest\"" *B=24
    (string parameters must be quoted)
    (your shell may require escaping and/or single quotes)
-----

Example rules are given in: i+clients/icommands/test/rules3.0/+.

In either form, the 'rule' that is processed is either a rule name or a rule
definition (which may be a complete rule or a subset).

To view the output parameters (+outParamDesc+), use the +-v+ option. 

*Options*:

-----
--test  - enable test mode so that the microservices are not executed,
            instead a loopback is performed
-s      - enable string mode, in string mode all command line input arguments
do not need
             to be quoted and are automatically converted to strings             
             string mode does not affect input parameter values in rule files
-F      - read the named inputFile
            if the inputFile begins with the prefix "i:"
            then the file is fetched from an iRODS server
-l      - list file if -F option is used
-v      - verbose
-h      - this help
-----

*Reference*:
https://wiki.irods.org/index.php/irule[+https://wiki.irods.org/index.php/irule+]

[[iqstat]]
+iqstat+
^^^^^^^^

*Summary*: Show information about your pending iRODS rule executions or for
the entered user.

*Usage*: +iqstat [-luvVh] [--showFirstLine] [-u user] [ruleId]+

*Options*:

-----
-a        display requests of all users
-l        for long format
-u user   for the specified user
--showFirstLine        show only the first line of rules ruleId for the
specified rule
-----

*Reference*:
https://wiki.irods.org/index.php/iqstat[+https://wiki.irods.org/index.php/iqstat+]

[[iqdel]]
+iqdel+
^^^^^^^

*Summary*: Removes delayed rules from the queue.

*Usage*: +iqdel [-vVh] ruleId [...]+

*Usage*: +iqdel [-a] [-u user]+

Multiple +ruleId+ values may be included on the command line.

*Options*:  

-----
-a - specifies the removal of all delayed rules
-u - specifies the removal of all delayed rules of the given user
-a and -u options cannot be used together
-----

*Reference*:
https://wiki.irods.org/index.php/iqdel[+https://wiki.irods.org/index.php/iqdel+]

[[iqmod]]
+iqmod+
^^^^^^^

*Summary*: Modifies values in existing delayed rules. 

*Usage*:  +iqmod [-vVh] ruleId FIELD_NAME fieldValue+

where:

* +FIELD_NAME+ can be +ruleName+, +reiFilePath+, +userName+, +exeAddress+,
+exeTime+, +exeFrequency+, +priority+, +estimateExeTime+, 
+notificationAddr+, +lastExeTime+ or +exeStatus+.

See also xref:iqstat[+iqstat+] and xref:iqdel[+iqdel+].

Reference:
https://wiki.irods.org/index.php/iqmod[+https://wiki.irods.org/index.php/iqmod+].

[[idbug]]
+idbug+
^^^^^^^

*Summary*: Command for rule debugging.

*Usage*: +idbug [-h][-v n] [-c|C]+

This command will obtain a command prompt wherein each of the
commands listed below can be entered and appended with the
string +for all+ or +for <num>+.  The message is then sent to
all irodsAgents involved with this debugging session or to just
only one.  +<num>+ is the index number of the
+host-address:pid+ of the irodsAgent and is given by
the command prompt +a+.  The available commands are:

-----
 : list all iRODS agents host-address:pid involved currently in the session.
 n|next : execute next action.
 s|step : step into next action.
 f|finish : step out of current action.
 c|continue : continue running rules/micro-services.
 C|Continue : same as 'c' but with steps shown.
 d|discontinue : discontinue. stop at next rule/micro-service. Useful in 'c' mode.
 b|break <action> [<qualifier>] : set breakpoint at a rule/micro-service.
 del|delete <num> : delete breakpoint <num>.
 l|list (r|rule <name>)|<name> : list rule, $-variables, *-variables, or breakpoints.
 p|print <expression> : print expression.
 w|where [<num>] : display <num> layers of rule/micro-service call stack. If <num> is not specified, display default number of steps.
 W|Where [<num>] : display <num> layers of full rule/micro-service call stack. If <num> is not specified, display default number of steps.
 q : cleanup and quit.
-----

*Options*:

-----
-h : prints this  help message 
  -v : verbose mode 1,2 or 3 
  -c : starts debugging in continue mode for all processes
  -C : same as -c but with steps shown
-----

[[cl-netcdf]]
NetCDF Commands
~~~~~~~~~~~~~~~

[[inc]]
+inc+
^^^^^

*Summary*: Perform NETCDF operations on the input data objects. The data
objects must be in NETCDF file format. 

*Usage*: +inc [-hr] [--header] [--dim] [--ascitime] [--noattr] [-o outFile] [--var 'var1 var2 ...'] [--subset 'dimName1[start%stride%end] ...']|[--SUBSET dimName1[startVal%stride%endVal]...] dataObj|collection ...+

*Usage*: +inc --agginfo [-l]|[w] [-R resource] collection ...+

where:

* +-o+ - specifies that the extracted data values will be put into the given +outFile+ in NetCDF
format instead of text format to the terminal (with this option available only if the client is
built with the NETCDF_API switched on, i.e. compiled and linked with the NetCDF C library);

* +--noattr+ - specifies that attributes will not be saved or displayed, with the attributes automatically
extracted by default

* +-var+ - used to specify a list of variables for data output to the terminal or to the +outFile+ in
NetCDF format, with a value of +all+ - as well as no specification of +-var+ - causing all variables to be output, e.g.
----
           inc --var 'pressure temperature current' myfile.nc
----

* +--subset+ - used to specify a list of subsetting conditions, with each
condition given in the form +dimName[start%stride%end]+ where
+start+ and +end+ are the starting and ending indices of the
dimension array, e.g.
-----
           inc --var pressure --subset 'longitude[2%1%8] latitude[4%1%5] time[2%1%4]' myfile.nc
-----
* +--SUBSET+ - used to specify a list of subsetting conditions using the values of
the dimension variable rather than the dimension indices as with +--subset+, with the
option of using either the dimension indices or ASCI value for +time+, e.g.
-----
           inc --SUBSET 'latitude[37.87%1%45.34] time[1146515400%1%1146533400]' myfile.nc
           inc --SUBSET 'latitude[37.87%1%45.34] time[2006-05-01T13:30:00%1%200-05-01T18:30:00]' myfile.nc
-----

If the specified path is a collection and the +-r+ option is not used, the input
collection is treated as an 'aggregate collection'. An 'aggregate collection'
is a collection containing multiple NETCDF files in a time series. The time
dimenion that ties these files together must have a case insensitive name
+time+ containing the number of seconds since the Epoch in values. Before the
collection can be used as an 'aggregate collection', a file named +.aggInfo+
which contains info such as starting time and ending time of each NETCDF files
in XML format sorted in ascending time order must exist. This file is
generated automatically by the time series archival command xref:incarch[+incarch+] or can
be generated using the +inc --agginfo -w myCollection+ command. Each NETCDF
file must have a +netcdf+ datatype (e.g., using xref:isysmeta[+isysmeta+] +mod datatype+ command
or automatically generated by the archival operation using xref:incarch[+incarch+]) for it
to be recognized as part of the aggregate file pool. If the +inc --agginfo -w+
command is used to generated the +.agginfo+ file and a file in the 'aggregate
collection' is not a +netcdf+ datatype, it is excluded from the +aggInfo+ while
the generation of +aggInfo+ continues. Then a +NETCDF_INVALID_DATA_TYPE+ error is
returned after the operation finished. Once the +.aggInfo+ file has been
generated, the 'aggregate collection' path will be treated as a single NETCDF
file spanning the entire time series by many of the NETCDF APIs and this
command. 

*Options*: 

-----
-o outFile - the extracted variable values will be put into the given
     outFile in NETCDF format. Only allowable if the client is built
     with the NETCDF_API switched on (compile and linked without the
     NETCDF C library)
-r  recursive operation on the collction
--agginfo - set or list the .aggInfo file of an aggregate collection
-l  list (cat) the content of the .aggInfo file to std out. Can only be
    used with --agginfo
-w  Get the aggregate info of the aggregate collection and write it
    into the .aggInfo file. Can only be used with --agginfo
-R  resource - specifies the resource to store the .aggInfo file. Can
    only be used with --agginfo and -w options.
--ascitime - For 'time' variable, output time in asci local time instead of 
     integer. e.g., 2006-05-01T08:30:00.
--header - output the header info (info on atrributes, dimensions and
     variables).
--dim - output the values of dimension variables.
--noattr - attributes will not be saved nor displayed.
--var 'var1 var2 ...' - list of variables or data output. A value of 'all'
     means all variables
--subset 'dimName1[start%stride%end] ...' - list of subsetting conditions in
     the form dimName[start%stride%end] where 'start' and 'end' are the
     starting and ending indices of the dimension array
--SUBSET 'dimName1[startVal%stride%endVal] ...' - list of subsetting
     conditions in the form dimName[startVal%stride%endVal] where 'startVal'
     and 'endVal' are the starting and ending values of the dimension array
-h  this help
-----

*Reference*:

https://wiki.irods.org/index.php/inc[+https://wiki.irods.org/index.php/inc+]

https://wiki.irods.org/index.php/NETCDF

[[incattr]]
+incattr+
^^^^^^^^^

*Summary*: Performs NetCDF attribute operations.

*Usage*:  +incattr [-hlMrv] [--reg]|[--remove]|[-q "attr Operator value [...]"] [--attr attrName [...]] dataObj|collection ...+

By default, the attribute name (key) associated with the data is listed. With the +-l+ option, both the attribute name and value will be listed for all AVU. With the +--attr+ option, only the AVU of the specified 'attribute names' will be listed. More than one 'attribute names' can be specified and they need to be enclosed in double quotes., e.g., 

-----
incattr -r --attr "title distance" pydap
-----

The +--reg+ option extracts and registers the global attributes of the NETCDF files. If +--attr+ is also specified, only the given global attribute names will be registered. The +-q+ option can be used to list all data files that meet the given AVU query constraints. The constraints are given in one or more 'attr Operator value' triplet. The constraint triplets must be enclosed in double quotes ("). Since each attribute name or value can contain more than one words, they can be enclosed in single quotes ('). e.g. 

-----
incattr -r -q "title = 'California Commercial Fish Landings'  distance '<=' 12" pydap
-----

Many operators are supported such as +>+, +<+, +=+, +like+, etc. In addition, wildcards in the attribute names and values are supported. Please see xref:imeta[+imeta+] +qu+ for details. 

*Options*:

-----
-l  list values for all attributes
-M  admin - admin user uses this option to extract and register the global
    attributes of other users files. It is only meaningful with --reg.
-q "attr Operator value" - list all data files that match the query
-r  recursive operation on the collction
-v  verbose mode
--attr attrName - given the atrribute names, list/register/remove the attribute value
--reg - extract and register the global attributes
--remove - unregister the global attributes
-h  this help
-----

*Reference*: 
 
https://wiki.irods.org/index.php/incattr[+https://wiki.irods.org/index.php/incattr+]

https://wiki.irods.org/index.php/NETCDF

[[incarch]]
+incarch+
^^^^^^^^^

*Summary*: Used to archive open-ended NetCDF time series data.

*Usage*: +incarch [-h] [-s fileSize][--new startingTimeIndex] sourceObjPath aggCollection+

This command can be used to archive a special class of NETCDF data - open
ended time series data that is being updated continuously. Typically these are
data served by Opendap servers such as Thredds Data Server (TDS) and ERDDAP
servers which aggregate multiple NETCDF files in a time series logically and
time series is presented to users as a single file. The time dimension must
have a case insensitive name +time+ containing the number of seconds since the
Epoch in values. Access of these NETCDF files can be achieved through the TDS
and ERDDAP drivers of iRODS once the URL of these files have been registered
with iCAT (see examples in https://www.irods.org/index.php/NETCDF). This
command can then be used to incrementally archive these time series data to an
iRODS 'aggregate collection'. An 'aggregate collection' is a collection
containing multiple NETCDF files in a time series tied together by the +time+
dimension.

Archival of the time series data is done by incrementally adding NETCDF files
to the 'aggregate collection'. In addition, the +.aggInfo+ file which contains
info such as starting time and ending time of each NETCDF files, is updated.
The +.aggInfo+ file is needed for a collection to be used as an 'aggregate
collection'.

The input +sourceObjPath+ is the path of the time series data to be archived.
Typically, this path represents an iRODS data object created through
registration (xref:ireg[+ireg+]) with the physical path representing a TDS or ERDDAP URL.

The input +aggCollection+ is the path of the target 'aggregate collection'.

The +--new+ option specifies that a brand new archive is to be started and the
+startingTimeIndex+ associated with this option specifies the +time+ dimension
index to start the archive. For example, if the +time+ dimension has an array
length (can be obtained with a xref:inc[+inc+] +--noattr+ command) of 1000. a
+startingTimeIndex+ of +0+ means that the new archive starts from the beginning of
the time series and a value of +999+ specifies the archive starts from the end.
If this option is not specified, an incremental backup from an existing
archive is assumed.

The +-s+ option specifies the approximate file size limit in MBytes of each
target file in the 'aggregate collection'. i.e, if the incremental backup
exceeds this limit, an archive file with size approximately equal to this
limit is created and new files are created to archive the additional data. The
default limit is 1 GBytes. It should be noted this limit is not strictly
enforced and up to 50% can be exceeded for the last file of an achive
operation to prevent creating small archive files. 

*Options*:

-----
-s fileSize - The size limit of each target archive file in MBytes.
      The default limit is 1 GBytes.
--new startingTimeIndex - Start a brand new time series archive.
      startingTimeIndex specifies the starting time index of the archive.
-h  this help
-----

*Reference*:

https://wiki.irods.org/index.php/incarch[+https://wiki.irods.org/index.php/incarch+]

https://wiki.irods.org/index.php/NETCDF[+https://wiki.irods.org/index.php/NETCDF+]

General Command-Line Options
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The options used by most or all of the i-commands are:

-----
 -a all
 -A access control list
 -b bulk
 -B backup mode
 -c:condition
 -C:collection
 -d dataObjects
 -D:dataType
 -e echo
 -f force
 -F file
 -g global
 -G group (or resource-group)
 -h help
 -i input - read data from standard input
 -k checksum
 -K verify checksum
 -l long
 -L very Long
 -m metadata
 -M admin mode
 -n:number-replica
 -N:number
 -p:physical-path
 -p parent (in imkdir)
 -P parallel
 -q query
 -Q rbudp transfer
 -r recursive
 -R:resource
 -s: size
 -S serial
 -t:ticket
 -T timed-reconnect - renew socket connections after 10 minutes
 -u:user
 -U unmount (imcoll), update (irepl)
 -v verbose
 -V veryVerbose
 -z:zone
----

Reference:
https://wiki.irods.org/index.php/command_line_options[+https://wiki.irods.org/index.php/command_line_options+]


Python Tools for iRODS
----------------------

This is a set of three subprojects:

* *PyRods* - a client API that can be used to create client applications
in Python which can communicate with a running iRODS system;

* *embedPython* - an iRODS module that allows the creation of
server-side workflows written in Python; and

* *PyRodsAdmin* - a set of administrative interfaces written in Python.

A presentation in PDF format can be obtained at:

https://irodspython.googlecode.com/files/PyRods-3.2.3.pdf[+https://irodspython.googlecode.com/files/PyRods-3.2.3.pdf+]

The package canbe obtained at:

https://code.google.com/p/irodspython/[+https://code.google.com/p/irodspython/+]


Installation
~~~~~~~~~~~~

See
https://code.google.com/p/irodspython/wiki/PyRodsInstall[+https://code.google.com/p/irodspython/wiki/PyRodsInstall+].

Get a local copy via git, configure it, compile it, and install it via:

-----
git clone https://code.google.com/p/irodspython/
cd irodspython/PyRods
export CFLAGS=-fPIC
scripts/configure
make clients
python setup.py build
su
python setup.py install
-----

PyRods
~~~~~~

PyRodsFile
^^^^^^^^^^

A wrapper for the iRodsFile class.  To
get file information:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

path = myEnv.rodsHome + '/testinfoio.txt'

# Open a file for writing
f = iRodsOpen(conn, path, 'w')
f.write("\/"*25)

print "Collection :", f.getCollName()
print "Data Name :", f.getDataName()
print "Desc Inx :", f.getDescInx()
print "Position :", f.getPosition()
print "Repl Number :", f.getReplNumber()
print "Resource Name :", f.getResourceName()
print "Size :", f.getSize()  # size = 0 because size is updated when you close the file

f.close()

f.delete()
 
conn.disconnect()
-----

To manage metadata:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

path = myEnv.rodsHome + '/testmeta.txt'
 
f = iRodsOpen(conn, path, 'w')

# There's 2 way to deal with metadata

# 1: If you have an iRodsFile object

f.addUserMetadata("units", "12", "cm")
f.addUserMetadata("author", "rods")
print f.getUserMetadata()
f.rmUserMetadata("author", "rods")
f.rmUserMetadata("units", "12", "cm")
print f.getUserMetadata()        
    
# 2: If you have the irods path of the file
addFileUserMetadata(conn, path, "units", "12", "cm")
addFileUserMetadata(conn, path, "author", "rods")
print getFileUserMetadata(conn, path)
rmFileUserMetadata(conn, path, "author", "rods") 
rmFileUserMetadata(conn, path, "units", "12", "cm")
print getFileUserMetadata(conn, path)     
   
f.close()
f.delete()
 
conn.disconnect()
-----

To read/write/append:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

path = myEnv.rodsHome + '/testsimpleio.txt'

# Write a string in a file
f = iRodsOpen(conn, path, 'w')
f.write("This is a test")
f.close()

# Read the file
f = iRodsOpen(conn, path, 'r')
print f.read()
f.close()    

# Read the file (give the buffer size)
f = iRodsOpen(conn, path, 'r')
print f.read(5)
print f.read()
f.close()    

# Append to the file
f = iRodsOpen(conn, path, 'a')
f.write("\nThis is still the test")
f.close()

# Read the file again
f = iRodsOpen(conn, path, 'r')
print f.read()
f.close()
 
conn.disconnect()
-----

To seek:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

path = myEnv.rodsHome + '/testseekio.txt'

# Write a string in a file
f = iRodsOpen(conn, path, 'w')
f.write("-" * 100)
f.close()

# Read the file from several positions
f = iRodsOpen(conn, path, 'r')
print "Size :", f.getSize()
f.seek(50, os.SEEK_SET) # middle
print f.read()
    
f.seek(0) # begining    
print f.read()
f.seek(f.getSize(), os.SEEK_END) # begining (from the end)
print f.read()    
f.close()

# Modify the file 
f = iRodsOpen(conn, path, 'a')
f.seek(-60, os.SEEK_CUR)
print "Begin position of modify :", f.getPosition()
f.write("+" * 20)
print "End position of modify :", f.getPosition()       
f.close()   

# Read the modified file 
f = iRodsOpen(conn, path, 'r')
print f.read()    
f.close()

f.delete()
 
conn.disconnect()
-----

To replicate files:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

# These 2 resources have to exist
resc1 = "demoResc"
resc2 = "demoResc2"
path = myEnv.rodsHome + '/testreplication.txt'

# If path exists on resc2, it will modify the version on resc2 and not create
# a new one on resc1. This is the choice of irods team.
f = iRodsOpen(conn, path, 'w', resc1)
f.write("=="*15)
f.close()

print "First read, both files are equal"

f = iRodsOpen(conn, path, 'r', resc1)
print "  Path:", f.getCollName(), f.getDataName()
print "  Resource Name :", f.getResourceName()
print "  Repl Number :", f.getReplNumber()
print "  Size :", f.getSize()
print "  Content :", f.read()
print
f.replicate(resc2)
f.close()

f = iRodsOpen(conn, path, 'r', resc2)
print "  Path:", f.getCollName(), f.getDataName()
print "  Resource Name :", f.getResourceName()
print "  Repl Number :", f.getReplNumber()
print "  Size :", f.getSize()
print "  Content :", f.read()
print
f.close()

print "Second read, first file is modified"

f = iRodsOpen(conn, path, 'a', resc1)
f.write("++"*15)
f.close()

f = iRodsOpen(conn, path, 'r', resc1)
print "  Path:", f.getCollName(), f.getDataName()
print "  Resource Name :", f.getResourceName()
print "  Repl Number :", f.getReplNumber()
print "  Size :", f.getSize()
print "  Content :", f.read()
print
f.close()

f = iRodsOpen(conn, path, 'r', resc2)
print "  Path:", f.getCollName(), f.getDataName()
print "  Resource Name :", f.getResourceName()
print "  Repl Number :", f.getReplNumber()
print "  Size :", f.getSize()
print "  Content :", f.read()
print
f.close()

print "Third read, synchronize the versions"

f.update()

f = iRodsOpen(conn, path, 'r', resc1)
print "  Path:", f.getCollName(), f.getDataName()
print "  Resource Name :", f.getResourceName()
print "  Repl Number :", f.getReplNumber()
print "  Size :", f.getSize()
print "  Content :", f.read()
print
f.close()

f = iRodsOpen(conn, path, 'r', resc2)
print "  Path:", f.getCollName(), f.getDataName()
print "  Resource Name :", f.getResourceName()
print "  Repl Number :", f.getReplNumber()
print "  Size :", f.getSize()
print "  Content :", f.read()
print
f.close()

print "Get the replicas"
f = iRodsOpen(conn, path, 'r', resc1)

for fi in f.getReplications():
    print "  Path:", fi.getCollName(), fi.getDataName()
    print "  Resource Name :", fi.getResourceName()
    print "  Repl Number :", fi.getReplNumber()
    print "  Size :", fi.getSize()
    print "  Content :", fi.read()
    print
    
    fi.close()
    fi.delete()    
    
f.close()
 
conn.disconnect()
-----

PyRodsUser
^^^^^^^^^^

A wrapper for the iRodsUser class.  To connect to a server:

-----
from irods import *

OBF_PWD_PATH = os.environ['HOME'] + "/.irods/.irodsA"

# Get the plain text password
status, password = obfGetPw()
# Get the encrypted password
status, obf_password = obfiGetPw(OBF_PWD_PATH)

# you can use obfiDecode(obf_password) or obfiEncode(password)
# to encode or decode a password

envVal = obfiGetEnvKey()
status, decoded_password = obfiDecode(obf_password, envVal)
print decoded_password
    
encoded_password = obfiEncode(password, envVal)
print encoded_password
    
status, decoded_password = obfiDecode(encoded_password, envVal)
print decoded_password

# Parse the .irodsEnv file
status, myEnv = getRodsEnv()

# Connection to a server with the default values
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)

# 3 different ways to log on the server
status = clientLogin(conn)
#status = clientLoginWithPassword(conn, password)
#status = clientLoginWithObfPassword(conn, obf_password)

# Do what you have to do
    
# Disconnect
conn.disconnect()
-----

To get user information:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)
    
# Get the information present in the iCAT
print getUserInfo(conn, "rods")

# Get an irodsUser object, the zone is optional
user = getUser(conn, myEnv.rodsUserName)
#user = getUser(conn, myEnv.rodsUserName, myEnv.rodsZone)
     
print "Id:", user.getId()
print "Name:", user.getName()
print "Type:", user.getTypeName()
print "Zone:", user.getZone()
print "Info:", user.getInfo()
print "Comment:", user.getComment()
print "Create TS:", user.getCreateTs()
print "Modify TS:", user.getModifyTs()

# You can modify some of the fields if you are admin
#user.setComment("Useful Comment")
#user.setInfo("Useful info")

# Be careful if you remove your user from rodsadmin you will have trouble to put it back
#user.setTypeName("rodsuser")
# Be careful with this one as changing the zone will change the authentication
#user.setZone("newZone")

# You can get the groups the user belongs to. You obtain irodsGroup instances
print "Member of :"
for g in user.getGroups():
    print "  -", g.getName()
  
conn.disconnect()
-----

To create/delete users:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

# Create a user with the name and the group
user = createUser(conn, "test", "rodsuser") 

# Delete a user
deleteUser(conn, "test")

conn.disconnect()
-----

To get a list of existing users:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

# Get a list of iRodsUser
for user in getUsers(conn):
    print "Id:", user.getId()
    print "Name:", user.getName()
    print "Type:", user.getTypeName()
    print "Zone:", user.getZone()
    print "Info:", user.getInfo()
    print "Comment:", user.getComment()
    print

conn.disconnect()
-----

To manage metadata:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

user = getUser(conn, myEnv.rodsUserName)

# Get a list of metadatas, a metadata is a tuple (name, value, units)
print user.getUserMetadata()
        
# Add some metadatas, the unit field is optional
user.addUserMetadata("test1", "value1")
user.addUserMetadata("test2", "value2", "units")
    
print user.getUserMetadata()
  
# Remove the metadatas we added
user.rmUserMetadata("test1", "value1")
user.rmUserMetadata("test2", "value2", "units")
    
print user.getUserMetadata()
    
conn.disconnect()
-----

PyRodsGroup
^^^^^^^^^^^

To get group information:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

# Get an iRodsGroup with its name
group = getGroup(conn, "public")   

# Get the fields
print "Id:", group.getId()
print "Name:", group.getName()
print "Type:", group.getTypeName()
print "Zone:", group.getZone()
print "Info:", group.getInfo()
print "Comment:", group.getComment()
print "Create TS:", group.getCreateTs()
print "Modify TS:", group.getModifyTs()

# You can modify some of the fields with an admin account
#group.setComment("Useful Comment")
#group.setInfo("Useful info")

# You can get the members of a group. You obtain iRodsUser instances    
for user in group.getMembers():
    print "Id:", user.getId()
    print "Name:", user.getName()
    print "Zone:", user.getZone()

conn.disconnect()
-----

To add/remove groups:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

# Create a group testAPI
group = createGroup(conn, "testAPI")   
# Delete the group
print deleteGroup(conn, "testAPI")
    
conn.disconnect()
-----

To add/remove a user in a group:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

group = createGroup(conn, "testAPI")    
# Add a user in the group            
group.addUser("cheshire")
# Remove the user from the group
group.rmUser("cheshire#cheshireZone")

deleteGroup(conn, "testAPI")

conn.disconnect()
-----

To manage metadata:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

group = getGroup(conn, "public")   

# Get a list of metadatas, a metadata is a tuple (name, value, units)
print group.getUserMetadata()

# Add some metadatas, the unit field is optional
group.addUserMetadata("test1", "value1")
group.addUserMetadata("test2", "value2", "units")

print group.getUserMetadata()

# Remove the metadatas we added
group.rmUserMetadata("test1", "value1")
group.rmUserMetadata("test2", "value2", "units")

print group.getUserMetadata()

conn.disconnect()
-----

To get a list of existing users:

-----
status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

# Get a list of iRodsUser
for group in getGroups(conn):
    print group.getName()

conn.disconnect()
-----

PyRodsResource
^^^^^^^^^^^^^^

To get resource information:

-----
from irods import *

rescName = "demoResc"

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

resc = getResource(conn, rescName)    

# Get some information
print "Id:", resc.getId()
print "Name:", resc.getName()
print "Zone:", resc.getZone()
print "Type:", resc.getTypeName()
print "Class:", resc.getClassName()
print "Host:", resc.getHost()
print "Path:", resc.getPath()
print "Free Space:", resc.getFreeSpace()
print "Free Space TS:", resc.getFreeSpaceTs()
print "Info:", resc.getInfo()
print "Comment:", resc.getComment()
print "Create TS:", resc.getCreateTs()
print "Modify TS:", resc.getModifyTs()
    
# Modify some fields
#resc.setTypeName("unix file system")
#resc.setClassName("archive")
#resc.setHost("localhost.localdomain")
#resc.setPath("/home/cheshire/build/iRODS/Vault")
resc.setComment("Useful comment")
resc.setInfo("Useful info")
resc.setFreeSpace("free comment")  
    
conn.disconnect()
-----

To get a list of existing resources:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

# Get a list of iRodsResource instances
for resc in getResources(conn):
    print "Id:", resc.getId()
    print "Name:", resc.getName()
    
conn.disconnect()
-----

To create/delete a resource:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

# Create a resource
resc = createResource(conn, "testResc", "unix file system", "archive", 
                      "localhost", " /home/jerome/testVault")
# Delete the resource
deleteResource(conn, "testResc") 

conn.disconnect()
-----

To manage metadata:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

resc = getResource(conn, rescName)

# Get a list of metadatas, a metadata is a tuple (name, value, units)
resc.getUserMetadata()

# Add some metadatas, the unit field is optional        
resc.addUserMetadata("test1", "value1")
resc.addUserMetadata("test2", "value2", "units")

print resc.getUserMetadata()
    
# Remove the metadatas we added
resc.rmUserMetadata("test1", "value1")
resc.rmUserMetadata("test2", "value2", "units")
    
print resc.getUserMetadata()

conn.disconnect()
-----

PyRodsZone
^^^^^^^^^^

To get zone information:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

zone = getZone(conn, myEnv.rodsZone)    

# Get Zone information
print "Id:", zone.getId()
print "Name:", zone.getName()
print "Type:", zone.getTypeName()
print "Conn String:", zone.getConn()
print "Comment:", zone.getComment()
print "Create TS:", zone.getCreateTs()
print "Modify TS:", zone.getModifyTs()

# You can modify some fields    
#zone.setConn("Conn Name")
#zone.setComment("Useful comment")
 
# Be careful with the modification of a local name as it will imply to
# modify .irodsEnv and core.irb
#zone.setName("tempZone2")
    
conn.disconnect()
-----

To get a list of existing zones:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

# Get a list of iRodsZone instances
for zone in getZones(conn):
    print "Id:", zone.getId()
    print "Name:", zone.getName()

conn.disconnect()
-----

To create/delete a zone:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

# Create a zone, the comment parameter is optional, there's also a connstr optional param
zone = createZone(conn, "testZone", "remote", comment="test")
# Delete the zone
deleteZone(conn, "testZone") 

conn.disconnect()
-----

PyRodsCollection
^^^^^^^^^^^^^^^^

To manage collections and files in collections:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

# These 2 resources have to exist
collName = "testCollection"        
resc1 = "demoResc"
resc2 = "demoResc2"

# Open the current working directory
c = irodsCollection(conn)

print c.getCollName()

c.createCollection("subCollection")
c.openCollection("subCollection")

print c.getCollName()

f = c.create("testCollection.txt")
nb_bytes_written = f.write("This is a test")
f.close()
# REPLICATE THE FILE AFTER CLOSING IT (BECAUSE MODE IS 'w')
f.replicate(resc2)    

f = c.create("testCollection2.txt", resc2)
nb_bytes_written = f.write("This is another test")
f.close()

print "Number of data objects :", c.getLenObjects()

print c.getObjects()

for dataObj in c.getObjects():
    data_name = dataObj[0]
    resc_name = dataObj[1]
    
    print data_name, resc_name
    
    f = c.open(data_name, "r", resc_name)
    
    print "  Path:", f.getCollName(), f.getDataName()
    print "  Resource Name :", f.getResourceName()
    print "  Repl Number :", f.getReplNumber()
    print "  Size :", f.getSize()
    print "  Content :", f.read()
    print 
    
    c.delete(data_name, resc_name)
    
    
c.upCollection()

print c.getCollName()
print "Number of subcollections :", c.getLenSubCollections()
print "  ", c.getSubCollections()


print "After deletion"
c.deleteCollection("subCollection")
print "Number of subcollections :", c.getLenSubCollections()
print "  ", c.getSubCollections()

c.upCollection()
c.deleteCollection(collName)

conn.disconnect()
-----

To manage metadata:

-----
from irods import *

status, myEnv = getRodsEnv()
conn, errMsg = rcConnect(myEnv.rodsHost, myEnv.rodsPort, myEnv.rodsUserName, myEnv.rodsZone)
status = clientLogin(conn)

path = myEnv.rodsHome

c = irodsCollection(conn, path)

# There's 2 way to deal with metadata

# 1: If you have an iRodsCollection object

# Add some metadata
c.addUserMetadata("units", "12", "cm")
c.addUserMetadata("author", "rods")
print c.getUserMetadata()    
c.rmUserMetadata("author", "rods")
c.rmUserMetadata("units", "12", "cm")    
print c.getUserMetadata()

# 2: If you have the irods path of the collection
addCollUserMetadata(conn, path, "units", "12", "cm")
addCollUserMetadata(conn, path, "author", "rods")
print getCollUserMetadata(conn, path)
rmCollUserMetadata(conn, path, "author", "rods")
rmCollUserMetadata(conn, path, "units", "12", "cm")
print getCollUserMetadata(conn, path)

conn.disconnect()
-----

PyRodsQuery
^^^^^^^^^^^

To get the users in a specific zone:

-----
from irods import *
from irods_error import *


def printGenQueryResults(conn, status, genQueryOut):        
    if status != 0:
        if status == CAT_NO_ROWS_FOUND:
            print "No result"
        else:
            print "Error : rcGenQuery - %d" % status
    else :
        sqlResults = genQueryOut.getSqlResult()
           
        res = [ sqlResult.getValues() for sqlResult in sqlResults ]
            
        for r in xrange(genQueryOut.getRowCnt()):
            for a in xrange(genQueryOut.getAttriCnt()):
                print res[a][r],
            print


# Connection
myEnv, status = getRodsEnv()
conn, errMsg = rcConnect(myEnv.getRodsHost(), myEnv.getRodsPort(), myEnv.getRodsUserName(), myEnv.getRodsZone())
status = clientLogin(conn)
       
genQueryInp = genQueryInp_t()

# Add the field we want to extract, this will be the attributes column in the
# genQueryOut variable
i1 = inxIvalPair_t()    
i1.addInxIval(COL_USER_NAME, 0)  # user name
i1.addInxIval(COL_USER_ZONE, 0)  # user zone

# Add some conditions to the query    
i2 = inxValPair_t()
i2.addInxVal(COL_USER_ZONE, "='tempZone'") # user of the tempZone only
i2.addInxVal(COL_USER_TYPE, "<>'rodsgroup'") # not a group (groups are in the user table)
    
genQueryInp.setSelectInp(i1)
genQueryInp.setSqlCondInp(i2)

genQueryInp.setMaxRows(10)
genQueryInp.setContinueInx(0)

# Query the icat    
genQueryOut, status = rcGenQuery(conn, genQueryInp)
       
printGenQueryResults(conn, status, genQueryOut)

# If there are more than maxRox result we need to iterate    
while status == 0 and genQueryOut.getContinueInx() > 0:
    genQueryInp.setContinueInx(genQueryOut.getContinueInx())
    genQueryOut, status = rcGenQuery(conn, genQueryInp)          
    printGenQueryResults(conn, status, genQueryOut)

conn.disconnect()
-----

To get files that match certain conditions:

-----
from irods import *
from irods_error import *


def printGenQueryResults(conn, status, genQueryOut):        
    if status != 0:
        if status == CAT_NO_ROWS_FOUND:
            print "No result"
        else:
            print "Error : rcGenQuery - %d" % status
    else :
        sqlResults = genQueryOut.getSqlResult()
           
        res = [ sqlResult.getValues() for sqlResult in sqlResults ]
            
        for r in xrange(genQueryOut.getRowCnt()):
            for a in xrange(genQueryOut.getAttriCnt()):
                print res[a][r],
            print


# Connection
myEnv, status = getRodsEnv()
conn, errMsg = rcConnect(myEnv.getRodsHost(), myEnv.getRodsPort(), myEnv.getRodsUserName(), myEnv.getRodsZone())
status = clientLogin(conn)


genQueryInp = genQueryInp_t()

# Select the attribute we want, order the result by data size 
i1 = inxIvalPair_t()    
i1.addInxIval(COL_COLL_NAME, 0)
i1.addInxIval(COL_DATA_NAME, 0)
i1.addInxIval(COL_DATA_SIZE, ORDER_BY)

# Add some conditions
i2 = inxValPair_t()
i2.addInxVal(COL_D_OWNER_NAME, "='rods'")     # Owner of the data
i2.addInxVal(COL_DATA_SIZE, "> '2000'")
i2.addInxVal(COL_DATA_SIZE, "< '5000'")       # size between 2ko and 5ko
i2.addInxVal(COL_COLL_NAME, "like '%test%'")  # the string test should be in the path
 
genQueryInp.setSelectInp(i1)
genQueryInp.setSqlCondInp(i2)
genQueryInp.setMaxRows(10)
genQueryInp.setContinueInx(0)

# Execute the query 
genQueryOut, status = rcGenQuery(conn, genQueryInp)
printGenQueryResults(conn, status, genQueryOut)
 
while status == 0 and genQueryOut.getContinueInx() > 0:
    genQueryInp.setContinueInx(genQueryOut.getContinueInx())
    genQueryOut, status = rcGenQuery(conn, genQueryInp)          
    printGenQueryResults(conn, status, genQueryOut)

conn.disconnect()
-----

embedPython
~~~~~~~~~~~

See
https://code.google.com/p/irodspython/wiki/EmbedPython[+https://code.google.com/p/irodspython/wiki/EmbedPython+].



PyRodsAdmin
~~~~~~~~~~~

This...

+python-irodsclient+ Interface
------------------------------

iRODS commands can be scripted using the Python interface available at:

https://github.com/iPlantCollaborativeOpenSource/python-irodsclient[+https://github.com/iPlantCollaborativeOpenSource/python-irodsclient+]

Installation
~~~~~~~~~~~~

Installation via pip can be done with the following:

-----
pip install git+git://github.com/iPlantCollaborativeOpenSource/pycommands.git
-----

Usage
~~~~~

Connecting
^^^^^^^^^^

As a user:

-----
>>> from irods.session import iRODSSession
>>> sess = iRODSSession(host='localhost', port=1247, user='rods', password='rods', zone='tempZone')
-----

As an adminstrator acting on behalf of another user:

-----
>>> from irods.session import iRODSSession
>>> sess = iRODSSession(host='localhost', port=1247, user='rods', password='rods', zone='tempZone', 
           client_user='another_user', client_zone='another_zone')
-----

Working with Collections
^^^^^^^^^^^^^^^^^^^^^^^^

-----
>>> coll = sess.collections.get("/tempZone/home/rods")

>>> coll.id
45798

>>> coll.path
/tempZone/home/rods

>>> for col in coll.subcollections:
>>>   print col
<iRODSCollection /tempZone/home/rods/subcol1>
<iRODSCollection /tempZone/home/rods/subcol2>

>>> for obj in coll.data_objects:
>>>   print obj
<iRODSDataObject /tempZone/home/rods/file.txt>
<iRODSDataObject /tempZone/home/rods/file2.txt>
-----

Create a new collection:

-----
>>> coll = sess.collections.create("/tempZone/home/rods/testdir")
>>> coll.id
45799
-----

Working with Data Objects/Files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Create a new data object:

-----
>>> obj = sess.data_objects.create("/tempZone/home/rods/test1")
<iRODSDataObject /tempZone/home/rods/test1>
-----

Get an existing data object:

-----
>>> obj = sess.data_objects.get("/tempZone/home/rods/test1")
>>> obj.id
12345

>>> obj.name
test1
>>> obj.collection
<iRODSCollection /tempZone/home/rods>
-----

Reading and Writing Files
^^^^^^^^^^^^^^^^^^^^^^^^^

File-like objects are used for reading and writing files.

-----
>>> obj = sess.data_objects.get("/tempZone/home/rods/test1")
>>> with obj.open('r+') as f:
...   f.write('foo\nbar\n')
...   f.seek(0,0)
...   for line in f:
...      print line
...
foo
bar
-----

Working with Metadata
^^^^^^^^^^^^^^^^^^^^^

-----
>>> obj = sess.data_objects.get("/tempZone/home/rods/test1")
>>> print obj.metadata.items()
[]

>>> obj.metadata.add('key1', 'value1', 'units1')
>>> obj.metadata.add('key1', 'value2')
>>> obj.metadata.add('key2', 'value3')
>>> print obj.metadata.items()
[<iRODSMeta (key1, value1, units1, 10014)>, <iRODSMeta (key2, value3, None,
10017)>, 
<iRODSMeta (key1, value2, None, 10020)>]

>>> print obj.metadata.get_all('key1')
[<iRODSMeta (key1, value1, units1, 10014)>, <iRODSMeta (key1, value2, None,
10020)>]

>>> print obj.metadata.get_one('key2')
<iRODSMeta (key2, value3, None, 10017)>

>>> obj.metadata.remove('key1', 'value1', 'units1')
>>> print obj.metadata.items()
[<iRODSMeta (key2, value3, None, 10017)>, <iRODSMeta (key1, value2, None,
10020)>]
-----

Performing General Queries
^^^^^^^^^^^^^^^^^^^^^^^^^^

-----
>>> from irods.session import iRODSSession
>>> from irods.models import Collection, User, DataObject
>>> sess = iRODSSession(host='localhost', port=1247, user='rods', password='rods', zone='tempZone')
>>> results = sess.query(DataObject.id, DataObject.name, DataObject.size, \
User.id, User.name, Collection.name).all()
>>> print results
+---------+-----------+-----------+---------------+--------------------------------+-----------+
| USER_ID | USER_NAME | D_DATA_ID | DATA_NAME     | COLL_NAME                      | DATA_SIZE |
+---------+-----------+-----------+---------------+--------------------------------+-----------+
| 10007   | rods      | 10012     | runDoxygen.rb | /tempZone/home/rods            | 5890      |
| 10007   | rods      | 10146     | test1         | /tempZone/home/rods            | 0         |
| 10007   | rods      | 10147     | test2         | /tempZone/home/rods            | 0         |
| 10007   | rods      | 10148     | test3         | /tempZone/home/rods            | 8         |
| 10007   | rods      | 10153     | test5         | /tempZone/home/rods            | 0         |
| 10007   | rods      | 10154     | test6         | /tempZone/home/rods            | 8         |
| 10007   | rods      | 10049     | .gitignore    | /tempZone/home/rods/pycommands | 12        |
| 10007   | rods      | 10054     | README.md     | /tempZone/home/rods/pycommands | 3795      |
| 10007   | rods      | 10052     | coll_test.py  | /tempZone/home/rods/pycommands | 658       |
| 10007   | rods      | 10014     | file_test.py  | /tempZone/home/rods/pycommands | 465       |
+---------+-----------+-----------+---------------+--------------------------------+-----------+
-----


Interfaces
----------

Descriptions of the available interfaces to iRODS.

Archivists Toolkit
~~~~~~~~~~~~~~~~~~

A archival data management system to provide broad, integrated support for the
management of archives.

http://archiviststoolkit.org/node/96[+http://archiviststoolkit.org/node/96+]

The integration of this with iRODS is discussed at:

https://wiki.irods.org/index.php/Extensions[+https://wiki.irods.org/index.php/Extensions+]

GridFTP
~~~~~~~

GridFTP is a high-performance, secure, reliable data transfer protocol
optimized for high-bandwidth wide-area networks. 

http://toolkit.globus.org/toolkit/docs/latest-stable/gridftp/[+http://toolkit.globus.org/toolkit/docs/latest-stable/gridftp/+]

A GridFTP module for iRODS is discussed at:

http://tu-dresden.de/die_tu_dresden/zentrale_einrichtungen/zih/forschung/grid_computing/iRODS[+http://tu-dresden.de/die_tu_dresden/zentrale_einrichtungen/zih/forschung/grid_computing/iRODS+]

Using this it is possible to  access files on GridFTP servers, transfer them
from/to iRODS and manage files/directories on GridFTP servers.  GSI proxy
certificates for every user are supported, or the iRODS server can be run
using a single certificate. The GridFTP microservices can be used with the
irule command or it is possible to automate their usage within iRODS actions.

iDrop
~~~~~

Provides interfaces and tools that provide individuals with a view of the
iRODS data grid.

https://code.renci.org/gf/project/irodsidrop/[+https://code.renci.org/gf/project/irodsidrop/+]

https://pods.iplantcollaborative.org/wiki/display/start/Using+iDrop+Desktop[+https://pods.iplantcollaborative.org/wiki/display/start/Using+iDrop+Desktop+]

http://www.youtube.com/watch?v=YhciVQCZuBY[+http://www.youtube.com/watch?v=YhciVQCZuBY+]

http://www.youtube.com/watch?v=1pu_EU3rmkU[+http://www.youtube.com/watch?v=1pu_EU3rmkU+]

LOCKSS
~~~~~~

The LOCKSS Program, based at Stanford University Libraries, provides libraries
and publishers with award-winning, low-cost, open source digital preservation
tools to preserve and provide access to persistent and authoritative digital
content.

http://www.lockss.org/[+http://www.lockss.org/+]

Integration of LOCKSS with iRODS is discussed at:


https://wiki.irods.org/index.php/Extensions[+https://wiki.irods.org/index.php/Extensions+]

http://digital.library.unt.edu/ark:/67531/metadc109714/[+http://digital.library.unt.edu/ark:/67531/metadc109714/+]

http://digital.library.unt.edu/ark:/67531/metadc109716/[+http://digital.library.unt.edu/ark:/67531/metadc109716/+]

L-Store
~~~~~~~

A flexible logistical storage framework for distributed and scalable access to
data for a wide spectrum of users. L-Store is designed to provide: virtually
unlimited scalability in raw storage; support for arbitrary metadata
associated with each file; user controlled fault tolerance and data
reliability on a file and directory level; scalable performance in raw data
movement; a virtual file system interface with both a native mount in Linux
(exportable via NFS and CIFS to other platforms) and a high performance
command line interface; and support for the geographical distribution and
migration of data to facilitate quick access. 

http://www.lstore.org/[+http://www.lstore.org/+]

Integration with iRODS is discussed at:

https://wiki.irods.org/index.php/Extensions[+https://wiki.irods.org/index.php/Extensions+]

PyRODS
~~~~~~

A set of tools that can be used to design client and server workflows for the
iRODS data grid server.

http://code.google.com/p/irodspython/[+http://code.google.com/p/irodspython/+]

python-irodsclient
~~~~~~~~~~~~~~~~~~

An iRODS client API implemented in Python.

https://github.com/iPlantCollaborativeOpenSource/python-irodsclient[+https://github.com/iPlantCollaborativeOpenSource/python-irodsclient+]

SRM
~~~

The Storage Resource Manager (SRM) is a protocol for resource management.

https://www.gridpp.ac.uk/wiki/SRM[+https://www.gridpp.ac.uk/wiki/SRM+]

An iRODS module for SRM is available at:

http://tu-dresden.de/die_tu_dresden/zentrale_einrichtungen/zih/forschung/grid_computing/iRODS[+http://tu-dresden.de/die_tu_dresden/zentrale_einrichtungen/zih/forschung/grid_computing/iRODS+]

which provides client SRM access to storage elements like dCache, DPM and
StoRM that support the SRM protocol.

dCache
^^^^^^

https://www.gridpp.ac.uk/wiki/DCache[+https://www.gridpp.ac.uk/wiki/DCache+]

DPM
^^^

https://www.gridpp.ac.uk/wiki/Disk_Pool_Manager[+https://www.gridpp.ac.uk/wiki/Disk_Pool_Manager+]

StoRM
^^^^^

http://italiangrid.github.io/storm/documentation/clientsrm-guide/[+http://italiangrid.github.io/storm/documentation/clientsrm-guide/+]

UNICORE
~~~~~~~

UNICORE (Uniform Interface to Computing Resources) offers a ready-to-run Grid
system including client and server software. UNICORE makes distributed
computing and data resources available in a seamless and secure way in
intranets and the internet.

http://www.unicore.eu/[+http://www.unicore.eu/+]

A UNICORE iRODS extension called UNIRODS is available at:

http://www-users.mat.umk.pl/~kaskader/unirods/installation.html[+http://www-users.mat.umk.pl/~kaskader/unirods/installation.html+]

webdavis
~~~~~~~~

WebDAV is a set of extensions to the HTTP protocol which allows users to
collaboratively edit and manage files on remote web servers. 

http://www.webdav.org/[+http://www.webdav.org/+]

A WebDAV interface for iRODS can be found at:

https://code.google.com/p/webdavis/[+https://code.google.com/p/webdavis/+]

Ancillary Software
------------------

Databases
~~~~~~~~~

Extending iRODS to include the management of database information is discussed
at:

https://wiki.irods.org/index.php/Database_Resources[+https://wiki.irods.org/index.php/Database_Resources+]

Pluggable interfaces are available as of version 4.0.0 for PostgreSQL, MySQL
and Oracle.

DSpace
~~~~~~

DSpace is a digital repository system for research material in digital
formats.

http://www.dspace.org/[+http://www.dspace.org/+]

Integration with iRODS is discussed at:

https://wiki.irods.org/index.php/DSpace[+https://wiki.irods.org/index.php/DSpace+]

ERDDAP
~~~~~~

An ERDDAP driver for iRODS 3.3.1 is at:

https://wiki.irods.org/doxygen/erddap_driver_8c_source.html[+https://wiki.irods.org/doxygen/erddap_driver_8c_source.html+]

The PyRODS wrapper for this is at:

http://code.google.com/p/irodspython/source/browse/PyRods/server/drivers/src/erddapDriver.c?spec=svnc3ef925c8f25a0694c9783905aaed69c7f5c1bf2&r=c3ef925c8f25a0694c9783905aaed69c7f5c1bf2[+http://code.google.com/p/irodspython/source/browse/PyRods/server/drivers/src/erddapDriver.c?spec=svnc3ef925c8f25a0694c9783905aaed69c7f5c1bf2&r=c3ef925c8f25a0694c9783905aaed69c7f5c1bf2+]

Installation
^^^^^^^^^^^^

The procedure to build an ERDDAP-enabled iRODS server is detailed at:

http://wiki.irods.org/index.php/NETCDF#3.29_ERDDAP_Server[+http://wiki.irods.org/index.php/NETCDF#3.29_ERDDAP_Server+]

The +config/config.mk+ file in the iRODS source code directory must be edited.
The line:

-----
# ERDDAP = 1
-----

must be uncommented.  And since OpenDAP support is needed, the NetCDF library
needs to be built with +--enable-netcdf-4+, so the line:

-----
# NETCDF4_API=1
-----

must also be uncommented.  The Jansson library at:

http://www.digip.org/jansson/[+http://www.digip.org/jansson/+]

for encoding, decoding and manipulating JSON data must be installed,
and the +LIB_JANSSON_INC_DIR+ and +LIB_JANSSON_LIB_DIR+ paths
defined in +config.mk+.  Now you can type +make+.

Usage
^^^^^

Here is an example of how to use the ERDDAP driver:

* Create an ERDDAP compound resource, e.g.
-----
iadmin mkresc erddapResc erddap compound srbbrick15.ucsd.edu  http://coastwatch.pfeg.noaa.gov/erddap/griddap/index.json
-----
*  Create a resource group, e.g.
-----
iadmin atrg erddapGrp erddapResc
iadmin atrg erddapGrp cacheResc
-----
where +cacheResc+ is a cache class resource on +srbbrick15.ucsd.edu+
* Register NetCDF data on an ERDDAP server with iCAT, e.g.
-----
ireg -CR erddapResc http://coastwatch.pfeg.noaa.gov/erddap/griddap/index.json /myZone/home/john/erddapData
-----
noting that the URL must be a JSON link
* The register files can now be treated as regular iRODS files.


*Note*: The driver works well with the grid data type on ERDDAP, but may have a problem with the table data type
because of constraint issues.


FUSE
~~~~

FUSE is software for implementing a fully functional filesystem in userspace.

http://fuse.sourceforge.net/[+http://fuse.sourceforge.net/+]

Integration with iDODS is discussed at:

https://wiki.irods.org/index.php/iRODS_FUSE[+https://wiki.irods.org/index.php/iRODS_FUSE+]

GSI
~~~

Grid Security Infrastructure is an authentication method.

http://toolkit.globus.org/toolkit/security/[+http://toolkit.globus.org/toolkit/security/+]

Integration with iRODS is discussed at:

https://wiki.irods.org/index.php/Grid_Security_Infrastructure[+https://wiki.irods.org/index.php/Grid_Security_Infrastructure+]

HDF5
~~~~

A library implementing a storage format for array-based data.

Integration with iRODS is discussed at:

https://wiki.irods.org/index.php/Extensions[+https://wiki.irods.org/index.php/Extensions+]

H-iRODS
~~~~~~~

A Hadoop file system interface implementation for iRODS.

https://github.com/iychoi/H-iRODS[+https://github.com/iychoi/H-iRODS+]

HPSS
~~~~

The High Performance Storage System (HPSS) is software that manages petabytes
of data on disk and robotic tape libraries. HPSS provides highly flexible and
scalable hierarchical storage management that keeps recently used data on disk
and less recently used data on tape.

http://www.hpss-collaboration.org/[+http://www.hpss-collaboration.org/+]

Integrating this with iRODS is discussed at:

https://wiki.irods.org/index.php/HPSS_Resource[+https://wiki.irods.org/index.php/HPSS_Resource+]

Kerberos
~~~~~~~~

Kerberos is a network authentication protocol.

http://web.mit.edu/Kerberos/[+http://web.mit.edu/Kerberos/+]

Integration with iRODS is discussed at:

https://wiki.irods.org/index.php/Extensions[+https://wiki.irods.org/index.php/Extensions+]

NetCDF
~~~~~~

NetCDF is a set of software libraries and self-describing, machine-independent
data formats that support the creation, access, and sharing of array-oriented
scientific data. 

http://www.unidata.ucar.edu/software/netcdf/[+http://www.unidata.ucar.edu/software/netcdf/+]

Integration with iRODS is discussed at:

https://wiki.irods.org/index.php/NETCDF[+https://wiki.irods.org/index.php/NETCDF+]

Parrot
~~~~~~

Parrot is a tool for attaching existing programs to remote I/O systems through
the filesystem interface.

http://www.cse.nd.edu/~ccl/software/parrot/[+http://www.cse.nd.edu/~ccl/software/parrot/+]

http://www.euasiagrid.org/wiki/index.php/Use_Parrot_for_attaching_existing_programs_to_remote_I/O_systems[+http://www.euasiagrid.org/wiki/index.php/Use_Parrot_for_attaching_existing_programs_to_remote_I/O_systems+]

Integration with iRODS is discussed at:

https://wiki.irods.org/index.php/Parrot[+https://wiki.irods.org/index.php/Parrot+]

S3
~~

S3 is the Amazon Simple Storage Service.

http://aws.amazon.com/s3/[+http://aws.amazon.com/s3/+]

Integrating this with iRODS is discussed at:

https://wiki.irods.org/index.php/S3_Resource[+https://wiki.irods.org/index.php/S3_Resource+]

SHAMAN
~~~~~~

Sustaining Heritage Access through Multivalent ArchiviNg (SHAMAN) addresses
the need for digital preservation of information.

http://shaman-ip.eu/[+http://shaman-ip.eu/+]

Integration with iRODS is discussed at:

https://wiki.irods.org/index.php/Extensions[+https://wiki.irods.org/index.php/Extensions+]

THREDDS
~~~~~~~

TDS resource plugin for iRODS:

https://github.com/irods/irods_resource_plugin_tds[+https://github.com/irods/irods_resource_plugin_tds+]

https://www.unidata.ucar.edu/support/help/MailArchives/netcdf-java/msg01376.html[+https://www.unidata.ucar.edu/support/help/MailArchives/netcdf-java/msg01376.html+]

http://code.google.com/p/webdavis/wiki/OpenDAP[+http://code.google.com/p/webdavis/wiki/OpenDAP+]


Security
--------

[[password]]
Password
~~~~~~~~

iRODS uses a secure password mechanism to authenticate users.
A challenge/response protocol using an MD5 hash confirms that the user has the
correct password, without sending it on the network. These MD5 routines are
derived from the RSA Data Security, Inc. MD5 Message-Digest Algorithm. This
MD5 is also used for iRODS data integrity checking. 

After one runs 'iinit' the password is saved on disk in a scrambled form. This
avoids storing plain-text passwords in files, and so improves security some.
(With the source code, however, one could descramble the passwords and the
algorithm is iRODS-specific and is not high-grade encryption.)

Database system (PostgreSQL) passwords are used to control access to the iCAT
database. These are stored in a server configuration file (by the install
script) also in a scrambled form.

iRODS user passwords are stored in the iCAT database. Access to these is
controlled and starting with iRODS 1.1, are stored in a scrambled form. 

[[GSI]]
+GSI+
~~~~~

iRODS supports GSI as an authentication method in addition to
the default password and other authentication methods.


To build GSI into iRODS, answer +yes+ to the GSI prompt from the +irodssetup+
script system. It will ask for the +GLOBUS_LOCATION+ and the +flavor+ of GSI
installation that you wish to use. 

Reference:

https://wiki.irods.org/index.php/GSI[+https://wiki.irods.org/index.php/GSI+]

http://toolkit.globus.org/toolkit/security/


Build Log
---------

The partial contents of the build log resulting from
the command:

-----
./build.sh icat postgres >& build.log &
-----

follow:

-----
+------------------------------------+
| RENCI iRODS Build Script           |
+------------------------------------+
Wed Apr 16 12:34:40 CDT 2014

Detecting Build Environment^[(B^[[m
Detected Packaging Directory [/home/baum/IRODS/irods/packaging]
Build Directory set to [/home/baum/IRODS/irods]
Detected iRODS Version to Build [4.0.0]
Detected iRODS Version Integer [400005]
Detected OS [RedHatCompatible]
Detected OS Version [6.3]
Detected Python.h [/usr/include/python2.6/Python.h]
Detected curl [/usr/bin/curl] v[7.19.7]
Detected wget [/usr/bin/wget] v[1.12]
Detected doxygen [/usr/bin/doxygen] v[1.6.1]
Detected help2man [/usr/local/bin/help2man] v[1.45.1]
Detected libfuse library [/usr/include/fuse.h
/usr/include/fuse/fuse.h]
Detected libcurl library [/usr/include/curl/curl.h]
Detected bzip2 library [/usr/local/include/bzlib.h
/usr/include/bzlib.h]
Detected zlib library [/usr/include/zlib.h]
Detected pam library [/usr/include/security/pam_appl.h]
Detected OpenSSL sha.h library [/usr/include/openssl/sha.h]
Detected mysql library [/usr/include/mysql/mysql.h]
Detected pcre library [/usr/include/pcre.h]
Detected libxml2 library [/usr/include/libxml2/libxml/parser.h]
Detected krb5 library [/usr/include/gssapi/gssapi.h
/usr/include/gssapi.h]

Detected CPUs:    4
Compiling with:   make -j 7

Configuring and Building iRODS

Configure iRODS

Step 1 of 3:  Verifying configuration...
    No database configured.

Step 2 of 3:  Checking host system...
    Host OS is Linux.
    Perl:        /usr/bin/perl
    C compiler:  /usr/bin/g++ (gcc)
      Flags:     none
    Loader:      /usr/bin/g++
      Flags:     none
    Archiver:    /usr/bin/ar
    Ranlib:      /usr/bin/ranlib

Step 3 of 3:  Updating configuration files...
    Updating config.mk...
        Created /home/baum/IRODS/irods/iRODS/config/config.mk
    Updating platform.mk...
        Created /home/baum/IRODS/irods/iRODS/config/platform.mk
    Updating irods.config...
    Updating irodsctl...

Done.
Configure iRODS

Step 1 of 3:  Verifying configuration...
    No database configured.

Step 2 of 3:  Checking host system...
    Host OS is Linux.
    Perl:        /usr/bin/perl
    C compiler:  /usr/bin/g++ (gcc)
      Flags:     none
    Loader:      /usr/bin/g++
      Flags:     none
    Archiver:    /usr/bin/ar
    Ranlib:      /usr/bin/ranlib

Step 3 of 3:  Updating configuration files...
    Updating config.mk...
        Created /home/baum/IRODS/irods/iRODS/config/config.mk
    Updating platform.mk...
        Created /home/baum/IRODS/irods/iRODS/config/platform.mk
    Updating irods.config...
    Updating irodsctl...

Done.
Configure iRODS

Step 1 of 3:  Verifying configuration...

Step 2 of 3:  Checking host system...
    Host OS is Linux.
    Perl:        /usr/bin/perl
    C compiler:  /usr/bin/g++ (gcc)
      Flags:     none
    Loader:      /usr/bin/g++
      Flags:     none
    Archiver:    /usr/bin/ar
    Ranlib:      /usr/bin/ranlib

Step 3 of 3:  Updating configuration files...
    Updating config.mk...
    Updating platform.mk...
        Skipped.  No change.
    Updating irods.config...
    Updating irodsctl...

Done.
make: Entering directory '/home/baum/IRODS/irods'
Getting irods_external_RedHatCompatible_CentOS6.tar.gz ->
irods_external.tar.gz...
make[2]: 'FakeTargetForMake' is up to date.
Libraries

...

+ cd /home/baum/IRODS/irods/linux-2.6-x86_64/BUILD
+ /bin/rm -rf /home/baum/IRODS/irods/linux-2.6-x86_64/buildroot
+ exit 0
epm: Product names should only contain letters and numbers!
EPM produced packages:
./linux-2.6-x86_64/irods-dev-4.0.0-linux-2.6-x86_64.rpm
./linux-2.6-x86_64/irods-icat-4.0.0-linux-2.6-x86_64.rpm
./linux-2.6-x86_64/irods-runtime-4.0.0-linux-2.6-x86_64.rpm
./plugins/database/linux-2.6-x86_64/irods-database-plugin-postgres-1.0-linux-2.6-x86_64.rpm
./plugins/database/linux-2.6-x86_64/irods-database-plugin-postgres93-1.0-linux-2.6-x86_64.rpm

renaming    [./linux*/irods-dev-*4.0.0*.rpm]
         to [./build/irods-dev-4.0.0-64bit-centos6.rpm]

renaming    [./linux*/irods-runtime-*4.0.0*.rpm]
         to [./build/irods-runtime-4.0.0-64bit-centos6.rpm]

renaming    [./linux*/irods-*4.0.0*.rpm]
         to [./build/irods-icat-4.0.0-64bit-centos6.rpm]

renaming    [./plugins/database/linux*/*database*postgres93*.rpm]
         to [./build/irods-database-plugin-postgres93-1.0-centos6.rpm]

renaming    [./plugins/database/linux*/*database*.rpm]
         to [./build/irods-database-plugin-postgres-1.0-centos6.rpm]

Contents of ./build:
total 407048
-rw-r--r--. 1 root root   2993325 Apr 16 12:40
irods-database-plugin-postgres-1.0-centos6.rpm
-rw-r--r--. 1 root root   2993335 Apr 16 12:40
irods-database-plugin-postgres93-1.0-centos6.rpm
-rw-r--r--. 1 root root  82515944 Apr 16 12:45
irods-dev-4.0.0-64bit-centos6.rpm
-rw-r--r--. 1 root root 325711194 Apr 16 12:43
irods-icat-4.0.0-64bit-centos6.rpm
-rw-r--r--. 1 root root   2592586 Apr 16 12:45
irods-runtime-4.0.0-64bit-centos6.rpm
^[[36m^[[1m
+------------------------------------+
| RENCI iRODS Build Script           |
|                                    |
|   Completed in 10m56s              |
+------------------------------------+
-----

